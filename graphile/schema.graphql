"""The root query type which gives access points into the data universe."""
type Query {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """Reads and enables pagination through a set of `Album`."""
  albums(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Album`."""
    orderBy: [AlbumsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AlbumCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlbumFilter
  ): AlbumsConnection

  """Reads and enables pagination through a set of `MbArtistRelease`."""
  mbArtistReleases(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MbArtistReleaseCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MbArtistReleaseFilter
  ): MbArtistReleasesConnection

  """Reads and enables pagination through a set of `MbArtist`."""
  mbArtists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MbArtist`."""
    orderBy: [MbArtistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MbArtistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MbArtistFilter
  ): MbArtistsConnection

  """Reads and enables pagination through a set of `MbRelease`."""
  mbReleases(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MbRelease`."""
    orderBy: [MbReleasesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MbReleaseCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MbReleaseFilter
  ): MbReleasesConnection

  """Reads and enables pagination through a set of `PlaylistFolder`."""
  playlistFolders(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistFolderCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistFolderFilter
  ): PlaylistFoldersConnection

  """Reads and enables pagination through a set of `PlaylistStat`."""
  playlistStats(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistStat`."""
    orderBy: [PlaylistStatsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistStatCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistStatFilter
  ): PlaylistStatsConnection

  """Reads and enables pagination through a set of `PlaylistTrack`."""
  playlistTracks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTrackFilter
  ): PlaylistTracksConnection

  """Reads and enables pagination through a set of `PlaylistTracksHistory`."""
  playlistTracksHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTracksHistoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTracksHistoryFilter
  ): PlaylistTracksHistoriesConnection

  """Reads and enables pagination through a set of `Playlist`."""
  playlists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistFilter
  ): PlaylistsConnection

  """Reads and enables pagination through a set of `Play`."""
  plays(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlayFilter
  ): PlaysConnection

  """Reads and enables pagination through a set of `Release`."""
  releases(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Release`."""
    orderBy: [ReleasesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReleaseCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ReleaseFilter
  ): ReleasesConnection

  """Reads and enables pagination through a set of `StarredStat`."""
  starredStats(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StarredStat`."""
    orderBy: [StarredStatsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StarredStatCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StarredStatFilter
  ): StarredStatsConnection

  """Reads and enables pagination through a set of `Track`."""
  tracks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter
  ): TracksConnection
  album(id: String!): Album
  mbArtistRelease(mbArtistId: UUID!, mbReleaseId: UUID!): MbArtistRelease
  mbArtist(id: UUID!): MbArtist
  mbRelease(id: UUID!): MbRelease
  playlistFolder(id: Int!): PlaylistFolder
  playlistFolderByName(name: String!): PlaylistFolder
  playlistTrack(playlistId: Int!, trackId: String!): PlaylistTrack
  playlistTracksHistory(historyId: Int!, playlistId: Int!, trackId: String!): PlaylistTracksHistory
  playlist(id: Int!): Playlist
  playlistByName(name: String!): Playlist
  play(id: Int!): Play
  release(id: UUID!): Release
  track(id: String!): Track

  """Reads and enables pagination through a set of `Track`."""
  searchPlaylistTracks(
    _playlistId: Int
    _tokens: [String]

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter
  ): TracksConnection

  """Reads and enables pagination through a set of `Track`."""
  searchTracks(
    _tokens: [String]

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter
  ): TracksConnection

  """Reads and enables pagination through a set of `Track`."""
  tracksInPlaylist(
    _playlistId: Int

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter
  ): TracksConnection
}

"""A connection to a list of `Album` values."""
type AlbumsConnection {
  """A list of `Album` objects."""
  nodes: [Album]!

  """
  A list of edges which contains the `Album` and cursor to aid in pagination.
  """
  edges: [AlbumsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Album` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AlbumAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Album` for these aggregates."""
    groupBy: [AlbumsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AlbumsHavingInput
  ): [AlbumAggregates!]
}

type Album {
  id: String!
  albumArtist: String
  album: String
  genre: String
  genreColor: String
  nTracks: BigInt
  year: Int
  totalDuration: BigInt
  createdAt: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `Album` edge in the connection."""
type AlbumsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Album` at the end of the edge."""
  node: Album
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type AlbumAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: AlbumSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AlbumDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: AlbumMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: AlbumMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: AlbumAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: AlbumDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: AlbumStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: AlbumStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: AlbumVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: AlbumVariancePopulationAggregates
}

type AlbumSumAggregates {
  """Sum of nTracks across the matching connection"""
  nTracks: BigFloat!

  """Sum of year across the matching connection"""
  year: BigInt!

  """Sum of totalDuration across the matching connection"""
  totalDuration: BigFloat!

  """Sum of createdAt across the matching connection"""
  createdAt: BigFloat!
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

type AlbumDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of albumArtist across the matching connection"""
  albumArtist: BigInt

  """Distinct count of album across the matching connection"""
  album: BigInt

  """Distinct count of genre across the matching connection"""
  genre: BigInt

  """Distinct count of genreColor across the matching connection"""
  genreColor: BigInt

  """Distinct count of nTracks across the matching connection"""
  nTracks: BigInt

  """Distinct count of year across the matching connection"""
  year: BigInt

  """Distinct count of totalDuration across the matching connection"""
  totalDuration: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt
}

type AlbumMinAggregates {
  """Minimum of nTracks across the matching connection"""
  nTracks: BigInt

  """Minimum of year across the matching connection"""
  year: Int

  """Minimum of totalDuration across the matching connection"""
  totalDuration: BigInt

  """Minimum of createdAt across the matching connection"""
  createdAt: BigInt
}

type AlbumMaxAggregates {
  """Maximum of nTracks across the matching connection"""
  nTracks: BigInt

  """Maximum of year across the matching connection"""
  year: Int

  """Maximum of totalDuration across the matching connection"""
  totalDuration: BigInt

  """Maximum of createdAt across the matching connection"""
  createdAt: BigInt
}

type AlbumAverageAggregates {
  """Mean average of nTracks across the matching connection"""
  nTracks: BigFloat

  """Mean average of year across the matching connection"""
  year: BigFloat

  """Mean average of totalDuration across the matching connection"""
  totalDuration: BigFloat

  """Mean average of createdAt across the matching connection"""
  createdAt: BigFloat
}

type AlbumDecilesDiscAggregates {
  """Deciles (discrete) of nTracks across the matching connection"""
  nTracks: BigFloat

  """Deciles (discrete) of year across the matching connection"""
  year: BigFloat

  """Deciles (discrete) of totalDuration across the matching connection"""
  totalDuration: BigFloat

  """Deciles (discrete) of createdAt across the matching connection"""
  createdAt: BigFloat
}

type AlbumStddevSampleAggregates {
  """Sample standard deviation of nTracks across the matching connection"""
  nTracks: BigFloat

  """Sample standard deviation of year across the matching connection"""
  year: BigFloat

  """
  Sample standard deviation of totalDuration across the matching connection
  """
  totalDuration: BigFloat

  """Sample standard deviation of createdAt across the matching connection"""
  createdAt: BigFloat
}

type AlbumStddevPopulationAggregates {
  """
  Population standard deviation of nTracks across the matching connection
  """
  nTracks: BigFloat

  """Population standard deviation of year across the matching connection"""
  year: BigFloat

  """
  Population standard deviation of totalDuration across the matching connection
  """
  totalDuration: BigFloat

  """
  Population standard deviation of createdAt across the matching connection
  """
  createdAt: BigFloat
}

type AlbumVarianceSampleAggregates {
  """Sample variance of nTracks across the matching connection"""
  nTracks: BigFloat

  """Sample variance of year across the matching connection"""
  year: BigFloat

  """Sample variance of totalDuration across the matching connection"""
  totalDuration: BigFloat

  """Sample variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

type AlbumVariancePopulationAggregates {
  """Population variance of nTracks across the matching connection"""
  nTracks: BigFloat

  """Population variance of year across the matching connection"""
  year: BigFloat

  """Population variance of totalDuration across the matching connection"""
  totalDuration: BigFloat

  """Population variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

"""Grouping methods for `Album` for usage during aggregation."""
enum AlbumsGroupBy {
  ID
  ALBUM_ARTIST
  ALBUM
  GENRE
  GENRE_COLOR
  N_TRACKS
  YEAR
  TOTAL_DURATION
  CREATED_AT
}

"""Conditions for `Album` aggregates."""
input AlbumsHavingInput {
  AND: [AlbumsHavingInput!]
  OR: [AlbumsHavingInput!]
  sum: AlbumsHavingSumInput
  distinctCount: AlbumsHavingDistinctCountInput
  min: AlbumsHavingMinInput
  max: AlbumsHavingMaxInput
  average: AlbumsHavingAverageInput
  deciles_disc: AlbumsHavingDecilesDiscInput
  stddevSample: AlbumsHavingStddevSampleInput
  stddevPopulation: AlbumsHavingStddevPopulationInput
  varianceSample: AlbumsHavingVarianceSampleInput
  variancePopulation: AlbumsHavingVariancePopulationInput
}

input AlbumsHavingSumInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input HavingBigintFilter {
  equalTo: BigInt
  notEqualTo: BigInt
  greaterThan: BigInt
  greaterThanOrEqualTo: BigInt
  lessThan: BigInt
  lessThanOrEqualTo: BigInt
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input AlbumsHavingDistinctCountInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingMinInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingMaxInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingAverageInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingDecilesDiscInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingStddevSampleInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingStddevPopulationInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingVarianceSampleInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input AlbumsHavingVariancePopulationInput {
  nTracks: HavingBigintFilter
  year: HavingIntFilter
  totalDuration: HavingBigintFilter
  createdAt: HavingBigintFilter
}

"""Methods to use when ordering `Album`."""
enum AlbumsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ALBUM_ARTIST_ASC
  ALBUM_ARTIST_DESC
  ALBUM_ASC
  ALBUM_DESC
  GENRE_ASC
  GENRE_DESC
  GENRE_COLOR_ASC
  GENRE_COLOR_DESC
  N_TRACKS_ASC
  N_TRACKS_DESC
  YEAR_ASC
  YEAR_DESC
  TOTAL_DURATION_ASC
  TOTAL_DURATION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Album` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AlbumCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `albumArtist` field."""
  albumArtist: String

  """Checks for equality with the object’s `album` field."""
  album: String

  """Checks for equality with the object’s `genre` field."""
  genre: String

  """Checks for equality with the object’s `genreColor` field."""
  genreColor: String

  """Checks for equality with the object’s `nTracks` field."""
  nTracks: BigInt

  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `totalDuration` field."""
  totalDuration: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: BigInt
}

"""
A filter to be used against `Album` object types. All fields are combined with a logical ‘and.’
"""
input AlbumFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `albumArtist` field."""
  albumArtist: StringFilter

  """Filter by the object’s `album` field."""
  album: StringFilter

  """Filter by the object’s `genre` field."""
  genre: StringFilter

  """Filter by the object’s `genreColor` field."""
  genreColor: StringFilter

  """Filter by the object’s `nTracks` field."""
  nTracks: BigIntFilter

  """Filter by the object’s `year` field."""
  year: IntFilter

  """Filter by the object’s `totalDuration` field."""
  totalDuration: BigIntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: BigIntFilter

  """Checks for all expressions in this list."""
  and: [AlbumFilter!]

  """Checks for any expressions in this list."""
  or: [AlbumFilter!]

  """Negates the expression."""
  not: AlbumFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String

  """Contains the specified string (unaccented case-insensitive)."""
  includesUnaccentInsensitive: String

  """Does not contain the specified string (unaccented case-insensitive)."""
  notIncludesUnaccentInsensitive: String

  """
  Matches the specified pattern (unaccented case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeUnaccentInsensitive: String

  """
  Does not match the specified pattern (unaccented case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeUnaccentInsensitive: String

  """
  Matches the specified regular expression (unaccented case-insensitive) using the ~* operator.
  """
  matchUnaccentInsensitive: String

  """
  Does not match the specified regular expression (unaccented case-insensitive) using the ~* operator.
  """
  notMatchUnaccentInsensitive: String
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""A connection to a list of `MbArtistRelease` values."""
type MbArtistReleasesConnection {
  """A list of `MbArtistRelease` objects."""
  nodes: [MbArtistRelease]!

  """
  A list of edges which contains the `MbArtistRelease` and cursor to aid in pagination.
  """
  edges: [MbArtistReleasesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `MbArtistRelease` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MbArtistReleaseAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `MbArtistRelease` for these aggregates.
    """
    groupBy: [MbArtistReleasesGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MbArtistReleasesHavingInput
  ): [MbArtistReleaseAggregates!]
}

type MbArtistRelease {
  mbArtistId: UUID!
  mbReleaseId: UUID!

  """Reads a single `MbArtist` that is related to this `MbArtistRelease`."""
  mbArtist: MbArtist

  """Reads a single `MbRelease` that is related to this `MbArtistRelease`."""
  mbRelease: MbRelease
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

type MbArtist {
  id: UUID!
  name: String!
  lastChecked: BigInt

  """Reads and enables pagination through a set of `MbArtistRelease`."""
  mbArtistReleases(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MbArtistReleaseCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MbArtistReleaseFilter
  ): MbArtistReleasesConnection!
}

"""Methods to use when ordering `MbArtistRelease`."""
enum MbArtistReleasesOrderBy {
  NATURAL
  MB_ARTIST_ID_ASC
  MB_ARTIST_ID_DESC
  MB_RELEASE_ID_ASC
  MB_RELEASE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  MB_ARTIST_BY_MB_ARTIST_ID__ID_ASC
  MB_ARTIST_BY_MB_ARTIST_ID__ID_DESC
  MB_ARTIST_BY_MB_ARTIST_ID__NAME_ASC
  MB_ARTIST_BY_MB_ARTIST_ID__NAME_DESC
  MB_ARTIST_BY_MB_ARTIST_ID__LAST_CHECKED_ASC
  MB_ARTIST_BY_MB_ARTIST_ID__LAST_CHECKED_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__ID_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__ID_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__TITLE_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__TITLE_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__TYPES_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__TYPES_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__ACKSTATE_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__ACKSTATE_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__RELEASE_DATE_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__RELEASE_DATE_DESC
  MB_RELEASE_BY_MB_RELEASE_ID__CREATED_AT_ASC
  MB_RELEASE_BY_MB_RELEASE_ID__CREATED_AT_DESC
}

"""
A condition to be used against `MbArtistRelease` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input MbArtistReleaseCondition {
  """Checks for equality with the object’s `mbArtistId` field."""
  mbArtistId: UUID

  """Checks for equality with the object’s `mbReleaseId` field."""
  mbReleaseId: UUID
}

"""
A filter to be used against `MbArtistRelease` object types. All fields are combined with a logical ‘and.’
"""
input MbArtistReleaseFilter {
  """Filter by the object’s `mbArtistId` field."""
  mbArtistId: UUIDFilter

  """Filter by the object’s `mbReleaseId` field."""
  mbReleaseId: UUIDFilter

  """Filter by the object’s `mbArtist` relation."""
  mbArtist: MbArtistFilter

  """Filter by the object’s `mbRelease` relation."""
  mbRelease: MbReleaseFilter

  """Checks for all expressions in this list."""
  and: [MbArtistReleaseFilter!]

  """Checks for any expressions in this list."""
  or: [MbArtistReleaseFilter!]

  """Negates the expression."""
  not: MbArtistReleaseFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against `MbArtist` object types. All fields are combined with a logical ‘and.’
"""
input MbArtistFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `lastChecked` field."""
  lastChecked: BigIntFilter

  """Filter by the object’s `mbArtistReleases` relation."""
  mbArtistReleases: MbArtistToManyMbArtistReleaseFilter

  """Some related `mbArtistReleases` exist."""
  mbArtistReleasesExist: Boolean

  """Checks for all expressions in this list."""
  and: [MbArtistFilter!]

  """Checks for any expressions in this list."""
  or: [MbArtistFilter!]

  """Negates the expression."""
  not: MbArtistFilter
}

"""
A filter to be used against many `MbArtistRelease` object types. All fields are combined with a logical ‘and.’
"""
input MbArtistToManyMbArtistReleaseFilter {
  """
  Every related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MbArtistReleaseFilter

  """
  Some related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MbArtistReleaseFilter

  """
  No related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MbArtistReleaseFilter

  """Aggregates across related `MbArtistRelease` match the filter criteria."""
  aggregates: MbArtistReleaseAggregatesFilter
}

"""
A filter to be used against aggregates of `MbArtistRelease` object types.
"""
input MbArtistReleaseAggregatesFilter {
  """
  A filter that must pass for the relevant `MbArtistRelease` object to be included within the aggregate.
  """
  filter: MbArtistReleaseFilter

  """Distinct count aggregate over matching `MbArtistRelease` objects."""
  distinctCount: MbArtistReleaseDistinctCountAggregateFilter
}

input MbArtistReleaseDistinctCountAggregateFilter {
  mbArtistId: BigIntFilter
  mbReleaseId: BigIntFilter
}

"""
A filter to be used against `MbRelease` object types. All fields are combined with a logical ‘and.’
"""
input MbReleaseFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `types` field."""
  types: StringListFilter

  """Filter by the object’s `ackstate` field."""
  ackstate: MbAckstatesFilter

  """Filter by the object’s `releaseDate` field."""
  releaseDate: BigIntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: BigIntFilter

  """Filter by the object’s `mbArtistReleases` relation."""
  mbArtistReleases: MbReleaseToManyMbArtistReleaseFilter

  """Some related `mbArtistReleases` exist."""
  mbArtistReleasesExist: Boolean

  """Checks for all expressions in this list."""
  and: [MbReleaseFilter!]

  """Checks for any expressions in this list."""
  or: [MbReleaseFilter!]

  """Negates the expression."""
  not: MbReleaseFilter
}

"""
A filter to be used against String List fields. All fields are combined with a logical ‘and.’
"""
input StringListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """Contains the specified list of values."""
  contains: [String]

  """Contained by the specified list of values."""
  containedBy: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]

  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String
}

"""
A filter to be used against MbAckstates fields. All fields are combined with a logical ‘and.’
"""
input MbAckstatesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: MbAckstates

  """Not equal to the specified value."""
  notEqualTo: MbAckstates

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: MbAckstates

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: MbAckstates

  """Included in the specified list."""
  in: [MbAckstates!]

  """Not included in the specified list."""
  notIn: [MbAckstates!]

  """Less than the specified value."""
  lessThan: MbAckstates

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: MbAckstates

  """Greater than the specified value."""
  greaterThan: MbAckstates

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: MbAckstates
}

enum MbAckstates {
  NEW
  TODO
  ACKED
}

"""
A filter to be used against many `MbArtistRelease` object types. All fields are combined with a logical ‘and.’
"""
input MbReleaseToManyMbArtistReleaseFilter {
  """
  Every related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MbArtistReleaseFilter

  """
  Some related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MbArtistReleaseFilter

  """
  No related `MbArtistRelease` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MbArtistReleaseFilter

  """Aggregates across related `MbArtistRelease` match the filter criteria."""
  aggregates: MbArtistReleaseAggregatesFilter
}

type MbRelease {
  id: UUID!
  title: String!
  types: [String]!
  ackstate: MbAckstates!
  releaseDate: BigInt
  createdAt: BigInt!

  """Reads and enables pagination through a set of `MbArtistRelease`."""
  mbArtistReleases(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MbArtistReleaseCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MbArtistReleaseFilter
  ): MbArtistReleasesConnection!
}

"""A `MbArtistRelease` edge in the connection."""
type MbArtistReleasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MbArtistRelease` at the end of the edge."""
  node: MbArtistRelease
}

type MbArtistReleaseAggregates {
  keys: [String!]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: MbArtistReleaseDistinctCountAggregates
}

type MbArtistReleaseDistinctCountAggregates {
  """Distinct count of mbArtistId across the matching connection"""
  mbArtistId: BigInt

  """Distinct count of mbReleaseId across the matching connection"""
  mbReleaseId: BigInt
}

"""Grouping methods for `MbArtistRelease` for usage during aggregation."""
enum MbArtistReleasesGroupBy {
  MB_ARTIST_ID
  MB_RELEASE_ID
}

"""Conditions for `MbArtistRelease` aggregates."""
input MbArtistReleasesHavingInput {
  AND: [MbArtistReleasesHavingInput!]
  OR: [MbArtistReleasesHavingInput!]
}

"""A connection to a list of `MbArtist` values."""
type MbArtistsConnection {
  """A list of `MbArtist` objects."""
  nodes: [MbArtist]!

  """
  A list of edges which contains the `MbArtist` and cursor to aid in pagination.
  """
  edges: [MbArtistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MbArtist` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MbArtistAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `MbArtist` for these aggregates."""
    groupBy: [MbArtistsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MbArtistsHavingInput
  ): [MbArtistAggregates!]
}

"""A `MbArtist` edge in the connection."""
type MbArtistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MbArtist` at the end of the edge."""
  node: MbArtist
}

type MbArtistAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: MbArtistSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: MbArtistDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: MbArtistMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: MbArtistMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: MbArtistAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: MbArtistDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: MbArtistStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: MbArtistStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: MbArtistVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: MbArtistVariancePopulationAggregates
}

type MbArtistSumAggregates {
  """Sum of lastChecked across the matching connection"""
  lastChecked: BigFloat!
}

type MbArtistDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of lastChecked across the matching connection"""
  lastChecked: BigInt
}

type MbArtistMinAggregates {
  """Minimum of lastChecked across the matching connection"""
  lastChecked: BigInt
}

type MbArtistMaxAggregates {
  """Maximum of lastChecked across the matching connection"""
  lastChecked: BigInt
}

type MbArtistAverageAggregates {
  """Mean average of lastChecked across the matching connection"""
  lastChecked: BigFloat
}

type MbArtistDecilesDiscAggregates {
  """Deciles (discrete) of lastChecked across the matching connection"""
  lastChecked: BigFloat
}

type MbArtistStddevSampleAggregates {
  """
  Sample standard deviation of lastChecked across the matching connection
  """
  lastChecked: BigFloat
}

type MbArtistStddevPopulationAggregates {
  """
  Population standard deviation of lastChecked across the matching connection
  """
  lastChecked: BigFloat
}

type MbArtistVarianceSampleAggregates {
  """Sample variance of lastChecked across the matching connection"""
  lastChecked: BigFloat
}

type MbArtistVariancePopulationAggregates {
  """Population variance of lastChecked across the matching connection"""
  lastChecked: BigFloat
}

"""Grouping methods for `MbArtist` for usage during aggregation."""
enum MbArtistsGroupBy {
  NAME
  LAST_CHECKED
}

"""Conditions for `MbArtist` aggregates."""
input MbArtistsHavingInput {
  AND: [MbArtistsHavingInput!]
  OR: [MbArtistsHavingInput!]
  sum: MbArtistsHavingSumInput
  distinctCount: MbArtistsHavingDistinctCountInput
  min: MbArtistsHavingMinInput
  max: MbArtistsHavingMaxInput
  average: MbArtistsHavingAverageInput
  deciles_disc: MbArtistsHavingDecilesDiscInput
  stddevSample: MbArtistsHavingStddevSampleInput
  stddevPopulation: MbArtistsHavingStddevPopulationInput
  varianceSample: MbArtistsHavingVarianceSampleInput
  variancePopulation: MbArtistsHavingVariancePopulationInput
}

input MbArtistsHavingSumInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingDistinctCountInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingMinInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingMaxInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingAverageInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingDecilesDiscInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingStddevSampleInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingStddevPopulationInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingVarianceSampleInput {
  lastChecked: HavingBigintFilter
}

input MbArtistsHavingVariancePopulationInput {
  lastChecked: HavingBigintFilter
}

"""Methods to use when ordering `MbArtist`."""
enum MbArtistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  LAST_CHECKED_ASC
  LAST_CHECKED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  MB_ARTIST_RELEASES_BY_MB_ARTIST_ID__COUNT_ASC
  MB_ARTIST_RELEASES_BY_MB_ARTIST_ID__COUNT_DESC
  MB_ARTIST_RELEASES_COUNT_ASC
  MB_ARTIST_RELEASES_COUNT_DESC
  MB_ARTIST_RELEASES_SUM_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_SUM_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_SUM_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_SUM_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_MIN_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_MIN_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_MIN_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_MIN_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_MAX_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_MAX_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_MAX_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_MAX_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_AVERAGE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_AVERAGE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_AVERAGE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_AVERAGE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_RELEASE_ID_DESC
}

"""
A condition to be used against `MbArtist` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MbArtistCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `lastChecked` field."""
  lastChecked: BigInt
}

"""A connection to a list of `MbRelease` values."""
type MbReleasesConnection {
  """A list of `MbRelease` objects."""
  nodes: [MbRelease]!

  """
  A list of edges which contains the `MbRelease` and cursor to aid in pagination.
  """
  edges: [MbReleasesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MbRelease` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MbReleaseAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `MbRelease` for these aggregates."""
    groupBy: [MbReleasesGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MbReleasesHavingInput
  ): [MbReleaseAggregates!]
}

"""A `MbRelease` edge in the connection."""
type MbReleasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MbRelease` at the end of the edge."""
  node: MbRelease
}

type MbReleaseAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: MbReleaseSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: MbReleaseDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: MbReleaseMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: MbReleaseMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: MbReleaseAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: MbReleaseDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: MbReleaseStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: MbReleaseStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: MbReleaseVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: MbReleaseVariancePopulationAggregates
}

type MbReleaseSumAggregates {
  """Sum of releaseDate across the matching connection"""
  releaseDate: BigFloat!

  """Sum of createdAt across the matching connection"""
  createdAt: BigFloat!
}

type MbReleaseDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of types across the matching connection"""
  types: BigInt

  """Distinct count of ackstate across the matching connection"""
  ackstate: BigInt

  """Distinct count of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt
}

type MbReleaseMinAggregates {
  """Minimum of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Minimum of createdAt across the matching connection"""
  createdAt: BigInt
}

type MbReleaseMaxAggregates {
  """Maximum of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Maximum of createdAt across the matching connection"""
  createdAt: BigInt
}

type MbReleaseAverageAggregates {
  """Mean average of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Mean average of createdAt across the matching connection"""
  createdAt: BigFloat
}

type MbReleaseDecilesDiscAggregates {
  """Deciles (discrete) of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Deciles (discrete) of createdAt across the matching connection"""
  createdAt: BigFloat
}

type MbReleaseStddevSampleAggregates {
  """
  Sample standard deviation of releaseDate across the matching connection
  """
  releaseDate: BigFloat

  """Sample standard deviation of createdAt across the matching connection"""
  createdAt: BigFloat
}

type MbReleaseStddevPopulationAggregates {
  """
  Population standard deviation of releaseDate across the matching connection
  """
  releaseDate: BigFloat

  """
  Population standard deviation of createdAt across the matching connection
  """
  createdAt: BigFloat
}

type MbReleaseVarianceSampleAggregates {
  """Sample variance of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Sample variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

type MbReleaseVariancePopulationAggregates {
  """Population variance of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Population variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

"""Grouping methods for `MbRelease` for usage during aggregation."""
enum MbReleasesGroupBy {
  TITLE
  TYPES
  ACKSTATE
  RELEASE_DATE
  CREATED_AT
}

"""Conditions for `MbRelease` aggregates."""
input MbReleasesHavingInput {
  AND: [MbReleasesHavingInput!]
  OR: [MbReleasesHavingInput!]
  sum: MbReleasesHavingSumInput
  distinctCount: MbReleasesHavingDistinctCountInput
  min: MbReleasesHavingMinInput
  max: MbReleasesHavingMaxInput
  average: MbReleasesHavingAverageInput
  deciles_disc: MbReleasesHavingDecilesDiscInput
  stddevSample: MbReleasesHavingStddevSampleInput
  stddevPopulation: MbReleasesHavingStddevPopulationInput
  varianceSample: MbReleasesHavingVarianceSampleInput
  variancePopulation: MbReleasesHavingVariancePopulationInput
}

input MbReleasesHavingSumInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingDistinctCountInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingMinInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingMaxInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingAverageInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingDecilesDiscInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingStddevSampleInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingStddevPopulationInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingVarianceSampleInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input MbReleasesHavingVariancePopulationInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

"""Methods to use when ordering `MbRelease`."""
enum MbReleasesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  TYPES_ASC
  TYPES_DESC
  ACKSTATE_ASC
  ACKSTATE_DESC
  RELEASE_DATE_ASC
  RELEASE_DATE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  MB_ARTIST_RELEASES_BY_MB_RELEASE_ID__COUNT_ASC
  MB_ARTIST_RELEASES_BY_MB_RELEASE_ID__COUNT_DESC
  MB_ARTIST_RELEASES_COUNT_ASC
  MB_ARTIST_RELEASES_COUNT_DESC
  MB_ARTIST_RELEASES_SUM_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_SUM_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_SUM_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_SUM_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_DISTINCT_COUNT_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_MIN_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_MIN_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_MIN_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_MIN_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_MAX_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_MAX_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_MAX_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_MAX_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_AVERAGE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_AVERAGE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_AVERAGE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_AVERAGE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_DECILES_DISC_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_SAMPLE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_STDDEV_POPULATION_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_SAMPLE_MB_RELEASE_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_ARTIST_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_ARTIST_ID_DESC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_RELEASE_ID_ASC
  MB_ARTIST_RELEASES_VARIANCE_POPULATION_MB_RELEASE_ID_DESC
}

"""
A condition to be used against `MbRelease` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MbReleaseCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `types` field."""
  types: [String]

  """Checks for equality with the object’s `ackstate` field."""
  ackstate: MbAckstates

  """Checks for equality with the object’s `releaseDate` field."""
  releaseDate: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: BigInt
}

"""A connection to a list of `PlaylistFolder` values."""
type PlaylistFoldersConnection {
  """A list of `PlaylistFolder` objects."""
  nodes: [PlaylistFolder]!

  """
  A list of edges which contains the `PlaylistFolder` and cursor to aid in pagination.
  """
  edges: [PlaylistFoldersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PlaylistFolder` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlaylistFolderAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `PlaylistFolder` for these aggregates."""
    groupBy: [PlaylistFoldersGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaylistFoldersHavingInput
  ): [PlaylistFolderAggregates!]
}

type PlaylistFolder {
  id: Int!
  name: String!
  ix: Int!

  """Reads and enables pagination through a set of `Playlist`."""
  playlists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistFilter
  ): PlaylistsConnection!
}

"""A connection to a list of `Playlist` values."""
type PlaylistsConnection {
  """A list of `Playlist` objects."""
  nodes: [Playlist]!

  """
  A list of edges which contains the `Playlist` and cursor to aid in pagination.
  """
  edges: [PlaylistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Playlist` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlaylistAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Playlist` for these aggregates."""
    groupBy: [PlaylistsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaylistsHavingInput
  ): [PlaylistAggregates!]
}

type Playlist {
  id: Int!
  playlistFolderId: Int
  name: String!
  sortCol: String
  sortAsc: Boolean
  ix: Int!

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """Reads and enables pagination through a set of `PlaylistTrack`."""
  playlistTracks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTrackFilter
  ): PlaylistTracksConnection!

  """Reads and enables pagination through a set of `PlaylistTracksHistory`."""
  playlistTracksHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTracksHistoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTracksHistoryFilter
  ): PlaylistTracksHistoriesConnection!
}

"""A connection to a list of `PlaylistTrack` values."""
type PlaylistTracksConnection {
  """A list of `PlaylistTrack` objects."""
  nodes: [PlaylistTrack]!

  """
  A list of edges which contains the `PlaylistTrack` and cursor to aid in pagination.
  """
  edges: [PlaylistTracksEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PlaylistTrack` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlaylistTrackAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `PlaylistTrack` for these aggregates."""
    groupBy: [PlaylistTracksGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaylistTracksHavingInput
  ): [PlaylistTrackAggregates!]
}

type PlaylistTrack {
  playlistId: Int!
  trackId: String!
  ix: Int!

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track
}

type Track {
  id: String!
  albumArtist: String
  artist: String
  album: String
  discI: Int
  discN: Int
  title: String
  trackI: Int
  trackN: Int
  duration: Int!
  composer: String
  grouping: String
  rating: Int
  year: Int
  genre: String
  compilation: Boolean!
  comments: String
  bitrate: Int!
  startAt: Int
  stopAt: Int
  fileSize: Int!
  ix: Int
  createdAt: BigInt!
  updatedAt: BigInt

  """Reads and enables pagination through a set of `PlaylistTrack`."""
  playlistTracks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTrackFilter
  ): PlaylistTracksConnection!

  """Reads and enables pagination through a set of `PlaylistTracksHistory`."""
  playlistTracksHistories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaylistTracksHistoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaylistTracksHistoryFilter
  ): PlaylistTracksHistoriesConnection!

  """Reads and enables pagination through a set of `Play`."""
  plays(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlayFilter
  ): PlaysConnection!
  genreCat: String
  genreColor: String
  lastPlayed: BigInt
  nPlays: Int
}

"""Methods to use when ordering `PlaylistTrack`."""
enum PlaylistTracksOrderBy {
  NATURAL
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  TRACK_ID_ASC
  TRACK_ID_DESC
  IX_ASC
  IX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PLAYLIST_BY_PLAYLIST_ID__ID_ASC
  PLAYLIST_BY_PLAYLIST_ID__ID_DESC
  PLAYLIST_BY_PLAYLIST_ID__PLAYLIST_FOLDER_ID_ASC
  PLAYLIST_BY_PLAYLIST_ID__PLAYLIST_FOLDER_ID_DESC
  PLAYLIST_BY_PLAYLIST_ID__NAME_ASC
  PLAYLIST_BY_PLAYLIST_ID__NAME_DESC
  PLAYLIST_BY_PLAYLIST_ID__SORT_COL_ASC
  PLAYLIST_BY_PLAYLIST_ID__SORT_COL_DESC
  PLAYLIST_BY_PLAYLIST_ID__SORT_ASC_ASC
  PLAYLIST_BY_PLAYLIST_ID__SORT_ASC_DESC
  PLAYLIST_BY_PLAYLIST_ID__IX_ASC
  PLAYLIST_BY_PLAYLIST_ID__IX_DESC
  TRACK_BY_TRACK_ID__ID_ASC
  TRACK_BY_TRACK_ID__ID_DESC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_ASC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_DESC
  TRACK_BY_TRACK_ID__ARTIST_ASC
  TRACK_BY_TRACK_ID__ARTIST_DESC
  TRACK_BY_TRACK_ID__ALBUM_ASC
  TRACK_BY_TRACK_ID__ALBUM_DESC
  TRACK_BY_TRACK_ID__DISC_I_ASC
  TRACK_BY_TRACK_ID__DISC_I_DESC
  TRACK_BY_TRACK_ID__DISC_N_ASC
  TRACK_BY_TRACK_ID__DISC_N_DESC
  TRACK_BY_TRACK_ID__TITLE_ASC
  TRACK_BY_TRACK_ID__TITLE_DESC
  TRACK_BY_TRACK_ID__TRACK_I_ASC
  TRACK_BY_TRACK_ID__TRACK_I_DESC
  TRACK_BY_TRACK_ID__TRACK_N_ASC
  TRACK_BY_TRACK_ID__TRACK_N_DESC
  TRACK_BY_TRACK_ID__DURATION_ASC
  TRACK_BY_TRACK_ID__DURATION_DESC
  TRACK_BY_TRACK_ID__COMPOSER_ASC
  TRACK_BY_TRACK_ID__COMPOSER_DESC
  TRACK_BY_TRACK_ID__GROUPING_ASC
  TRACK_BY_TRACK_ID__GROUPING_DESC
  TRACK_BY_TRACK_ID__RATING_ASC
  TRACK_BY_TRACK_ID__RATING_DESC
  TRACK_BY_TRACK_ID__YEAR_ASC
  TRACK_BY_TRACK_ID__YEAR_DESC
  TRACK_BY_TRACK_ID__GENRE_ASC
  TRACK_BY_TRACK_ID__GENRE_DESC
  TRACK_BY_TRACK_ID__COMPILATION_ASC
  TRACK_BY_TRACK_ID__COMPILATION_DESC
  TRACK_BY_TRACK_ID__COMMENTS_ASC
  TRACK_BY_TRACK_ID__COMMENTS_DESC
  TRACK_BY_TRACK_ID__BITRATE_ASC
  TRACK_BY_TRACK_ID__BITRATE_DESC
  TRACK_BY_TRACK_ID__START_AT_ASC
  TRACK_BY_TRACK_ID__START_AT_DESC
  TRACK_BY_TRACK_ID__STOP_AT_ASC
  TRACK_BY_TRACK_ID__STOP_AT_DESC
  TRACK_BY_TRACK_ID__FILE_SIZE_ASC
  TRACK_BY_TRACK_ID__FILE_SIZE_DESC
  TRACK_BY_TRACK_ID__IX_ASC
  TRACK_BY_TRACK_ID__IX_DESC
  TRACK_BY_TRACK_ID__CREATED_AT_ASC
  TRACK_BY_TRACK_ID__CREATED_AT_DESC
  TRACK_BY_TRACK_ID__UPDATED_AT_ASC
  TRACK_BY_TRACK_ID__UPDATED_AT_DESC
  TRACK_BY_TRACK_ID__GENRE_CAT_ASC
  TRACK_BY_TRACK_ID__GENRE_CAT_DESC
  TRACK_BY_TRACK_ID__GENRE_COLOR_ASC
  TRACK_BY_TRACK_ID__GENRE_COLOR_DESC
  TRACK_BY_TRACK_ID__LAST_PLAYED_ASC
  TRACK_BY_TRACK_ID__LAST_PLAYED_DESC
  TRACK_BY_TRACK_ID__N_PLAYS_ASC
  TRACK_BY_TRACK_ID__N_PLAYS_DESC
}

"""
A condition to be used against `PlaylistTrack` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PlaylistTrackCondition {
  """Checks for equality with the object’s `playlistId` field."""
  playlistId: Int

  """Checks for equality with the object’s `trackId` field."""
  trackId: String

  """Checks for equality with the object’s `ix` field."""
  ix: Int
}

"""
A filter to be used against `PlaylistTrack` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistTrackFilter {
  """Filter by the object’s `playlistId` field."""
  playlistId: IntFilter

  """Filter by the object’s `trackId` field."""
  trackId: StringFilter

  """Filter by the object’s `ix` field."""
  ix: IntFilter

  """Filter by the object’s `playlist` relation."""
  playlist: PlaylistFilter

  """Filter by the object’s `track` relation."""
  track: TrackFilter

  """Checks for all expressions in this list."""
  and: [PlaylistTrackFilter!]

  """Checks for any expressions in this list."""
  or: [PlaylistTrackFilter!]

  """Negates the expression."""
  not: PlaylistTrackFilter
}

"""
A filter to be used against `Playlist` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `playlistFolderId` field."""
  playlistFolderId: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `sortCol` field."""
  sortCol: StringFilter

  """Filter by the object’s `sortAsc` field."""
  sortAsc: BooleanFilter

  """Filter by the object’s `ix` field."""
  ix: IntFilter

  """Filter by the object’s `playlistTracks` relation."""
  playlistTracks: PlaylistToManyPlaylistTrackFilter

  """Some related `playlistTracks` exist."""
  playlistTracksExist: Boolean

  """Filter by the object’s `playlistTracksHistories` relation."""
  playlistTracksHistories: PlaylistToManyPlaylistTracksHistoryFilter

  """Some related `playlistTracksHistories` exist."""
  playlistTracksHistoriesExist: Boolean

  """Filter by the object’s `playlistFolder` relation."""
  playlistFolder: PlaylistFolderFilter

  """A related `playlistFolder` exists."""
  playlistFolderExists: Boolean

  """Checks for all expressions in this list."""
  and: [PlaylistFilter!]

  """Checks for any expressions in this list."""
  or: [PlaylistFilter!]

  """Negates the expression."""
  not: PlaylistFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many `PlaylistTrack` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistToManyPlaylistTrackFilter {
  """
  Every related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlaylistTrackFilter

  """
  Some related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlaylistTrackFilter

  """
  No related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlaylistTrackFilter

  """Aggregates across related `PlaylistTrack` match the filter criteria."""
  aggregates: PlaylistTrackAggregatesFilter
}

"""
A filter to be used against aggregates of `PlaylistTrack` object types.
"""
input PlaylistTrackAggregatesFilter {
  """
  A filter that must pass for the relevant `PlaylistTrack` object to be included within the aggregate.
  """
  filter: PlaylistTrackFilter

  """Sum aggregate over matching `PlaylistTrack` objects."""
  sum: PlaylistTrackSumAggregateFilter

  """Distinct count aggregate over matching `PlaylistTrack` objects."""
  distinctCount: PlaylistTrackDistinctCountAggregateFilter

  """Minimum aggregate over matching `PlaylistTrack` objects."""
  min: PlaylistTrackMinAggregateFilter

  """Maximum aggregate over matching `PlaylistTrack` objects."""
  max: PlaylistTrackMaxAggregateFilter

  """Mean average aggregate over matching `PlaylistTrack` objects."""
  average: PlaylistTrackAverageAggregateFilter

  """Deciles (discrete) aggregate over matching `PlaylistTrack` objects."""
  decilesDisc: PlaylistTrackDecilesDiscAggregateFilter

  """
  Sample standard deviation aggregate over matching `PlaylistTrack` objects.
  """
  stddevSample: PlaylistTrackStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `PlaylistTrack` objects.
  """
  stddevPopulation: PlaylistTrackStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `PlaylistTrack` objects."""
  varianceSample: PlaylistTrackVarianceSampleAggregateFilter

  """Population variance aggregate over matching `PlaylistTrack` objects."""
  variancePopulation: PlaylistTrackVariancePopulationAggregateFilter
}

input PlaylistTrackSumAggregateFilter {
  playlistId: BigIntFilter
  ix: BigIntFilter
}

input PlaylistTrackDistinctCountAggregateFilter {
  playlistId: BigIntFilter
  trackId: BigIntFilter
  ix: BigIntFilter
}

input PlaylistTrackMinAggregateFilter {
  playlistId: IntFilter
  ix: IntFilter
}

input PlaylistTrackMaxAggregateFilter {
  playlistId: IntFilter
  ix: IntFilter
}

input PlaylistTrackAverageAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

input PlaylistTrackDecilesDiscAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTrackStddevSampleAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTrackStddevPopulationAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTrackVarianceSampleAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTrackVariancePopulationAggregateFilter {
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

"""
A filter to be used against many `PlaylistTracksHistory` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistToManyPlaylistTracksHistoryFilter {
  """
  Every related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlaylistTracksHistoryFilter

  """
  Some related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlaylistTracksHistoryFilter

  """
  No related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlaylistTracksHistoryFilter

  """
  Aggregates across related `PlaylistTracksHistory` match the filter criteria.
  """
  aggregates: PlaylistTracksHistoryAggregatesFilter
}

"""
A filter to be used against `PlaylistTracksHistory` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistTracksHistoryFilter {
  """Filter by the object’s `historyId` field."""
  historyId: IntFilter

  """Filter by the object’s `playlistId` field."""
  playlistId: IntFilter

  """Filter by the object’s `trackId` field."""
  trackId: StringFilter

  """Filter by the object’s `ix` field."""
  ix: IntFilter

  """Filter by the object’s `playlist` relation."""
  playlist: PlaylistFilter

  """Filter by the object’s `track` relation."""
  track: TrackFilter

  """Checks for all expressions in this list."""
  and: [PlaylistTracksHistoryFilter!]

  """Checks for any expressions in this list."""
  or: [PlaylistTracksHistoryFilter!]

  """Negates the expression."""
  not: PlaylistTracksHistoryFilter
}

"""
A filter to be used against `Track` object types. All fields are combined with a logical ‘and.’
"""
input TrackFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `albumArtist` field."""
  albumArtist: StringFilter

  """Filter by the object’s `artist` field."""
  artist: StringFilter

  """Filter by the object’s `album` field."""
  album: StringFilter

  """Filter by the object’s `discI` field."""
  discI: IntFilter

  """Filter by the object’s `discN` field."""
  discN: IntFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `trackI` field."""
  trackI: IntFilter

  """Filter by the object’s `trackN` field."""
  trackN: IntFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `composer` field."""
  composer: StringFilter

  """Filter by the object’s `grouping` field."""
  grouping: StringFilter

  """Filter by the object’s `rating` field."""
  rating: IntFilter

  """Filter by the object’s `year` field."""
  year: IntFilter

  """Filter by the object’s `genre` field."""
  genre: StringFilter

  """Filter by the object’s `compilation` field."""
  compilation: BooleanFilter

  """Filter by the object’s `comments` field."""
  comments: StringFilter

  """Filter by the object’s `bitrate` field."""
  bitrate: IntFilter

  """Filter by the object’s `startAt` field."""
  startAt: IntFilter

  """Filter by the object’s `stopAt` field."""
  stopAt: IntFilter

  """Filter by the object’s `fileSize` field."""
  fileSize: IntFilter

  """Filter by the object’s `ix` field."""
  ix: IntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: BigIntFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: BigIntFilter

  """Filter by the object’s `genreCat` field."""
  genreCat: StringFilter

  """Filter by the object’s `genreColor` field."""
  genreColor: StringFilter

  """Filter by the object’s `lastPlayed` field."""
  lastPlayed: BigIntFilter

  """Filter by the object’s `nPlays` field."""
  nPlays: IntFilter

  """Filter by the object’s `playlistTracks` relation."""
  playlistTracks: TrackToManyPlaylistTrackFilter

  """Some related `playlistTracks` exist."""
  playlistTracksExist: Boolean

  """Filter by the object’s `playlistTracksHistories` relation."""
  playlistTracksHistories: TrackToManyPlaylistTracksHistoryFilter

  """Some related `playlistTracksHistories` exist."""
  playlistTracksHistoriesExist: Boolean

  """Filter by the object’s `plays` relation."""
  plays: TrackToManyPlayFilter

  """Some related `plays` exist."""
  playsExist: Boolean

  """Checks for all expressions in this list."""
  and: [TrackFilter!]

  """Checks for any expressions in this list."""
  or: [TrackFilter!]

  """Negates the expression."""
  not: TrackFilter
}

"""
A filter to be used against many `PlaylistTrack` object types. All fields are combined with a logical ‘and.’
"""
input TrackToManyPlaylistTrackFilter {
  """
  Every related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlaylistTrackFilter

  """
  Some related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlaylistTrackFilter

  """
  No related `PlaylistTrack` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlaylistTrackFilter

  """Aggregates across related `PlaylistTrack` match the filter criteria."""
  aggregates: PlaylistTrackAggregatesFilter
}

"""
A filter to be used against many `PlaylistTracksHistory` object types. All fields are combined with a logical ‘and.’
"""
input TrackToManyPlaylistTracksHistoryFilter {
  """
  Every related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlaylistTracksHistoryFilter

  """
  Some related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlaylistTracksHistoryFilter

  """
  No related `PlaylistTracksHistory` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlaylistTracksHistoryFilter

  """
  Aggregates across related `PlaylistTracksHistory` match the filter criteria.
  """
  aggregates: PlaylistTracksHistoryAggregatesFilter
}

"""
A filter to be used against aggregates of `PlaylistTracksHistory` object types.
"""
input PlaylistTracksHistoryAggregatesFilter {
  """
  A filter that must pass for the relevant `PlaylistTracksHistory` object to be included within the aggregate.
  """
  filter: PlaylistTracksHistoryFilter

  """Sum aggregate over matching `PlaylistTracksHistory` objects."""
  sum: PlaylistTracksHistorySumAggregateFilter

  """
  Distinct count aggregate over matching `PlaylistTracksHistory` objects.
  """
  distinctCount: PlaylistTracksHistoryDistinctCountAggregateFilter

  """Minimum aggregate over matching `PlaylistTracksHistory` objects."""
  min: PlaylistTracksHistoryMinAggregateFilter

  """Maximum aggregate over matching `PlaylistTracksHistory` objects."""
  max: PlaylistTracksHistoryMaxAggregateFilter

  """Mean average aggregate over matching `PlaylistTracksHistory` objects."""
  average: PlaylistTracksHistoryAverageAggregateFilter

  """
  Deciles (discrete) aggregate over matching `PlaylistTracksHistory` objects.
  """
  decilesDisc: PlaylistTracksHistoryDecilesDiscAggregateFilter

  """
  Sample standard deviation aggregate over matching `PlaylistTracksHistory` objects.
  """
  stddevSample: PlaylistTracksHistoryStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `PlaylistTracksHistory` objects.
  """
  stddevPopulation: PlaylistTracksHistoryStddevPopulationAggregateFilter

  """
  Sample variance aggregate over matching `PlaylistTracksHistory` objects.
  """
  varianceSample: PlaylistTracksHistoryVarianceSampleAggregateFilter

  """
  Population variance aggregate over matching `PlaylistTracksHistory` objects.
  """
  variancePopulation: PlaylistTracksHistoryVariancePopulationAggregateFilter
}

input PlaylistTracksHistorySumAggregateFilter {
  historyId: BigIntFilter
  playlistId: BigIntFilter
  ix: BigIntFilter
}

input PlaylistTracksHistoryDistinctCountAggregateFilter {
  historyId: BigIntFilter
  playlistId: BigIntFilter
  trackId: BigIntFilter
  ix: BigIntFilter
}

input PlaylistTracksHistoryMinAggregateFilter {
  historyId: IntFilter
  playlistId: IntFilter
  ix: IntFilter
}

input PlaylistTracksHistoryMaxAggregateFilter {
  historyId: IntFilter
  playlistId: IntFilter
  ix: IntFilter
}

input PlaylistTracksHistoryAverageAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTracksHistoryDecilesDiscAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTracksHistoryStddevSampleAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTracksHistoryStddevPopulationAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTracksHistoryVarianceSampleAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistTracksHistoryVariancePopulationAggregateFilter {
  historyId: BigFloatFilter
  playlistId: BigFloatFilter
  ix: BigFloatFilter
}

"""
A filter to be used against many `Play` object types. All fields are combined with a logical ‘and.’
"""
input TrackToManyPlayFilter {
  """
  Every related `Play` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlayFilter

  """
  Some related `Play` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlayFilter

  """
  No related `Play` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlayFilter

  """Aggregates across related `Play` match the filter criteria."""
  aggregates: PlayAggregatesFilter
}

"""
A filter to be used against `Play` object types. All fields are combined with a logical ‘and.’
"""
input PlayFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `trackId` field."""
  trackId: StringFilter

  """Filter by the object’s `dt` field."""
  dt: BigIntFilter

  """Filter by the object’s `track` relation."""
  track: TrackFilter

  """Checks for all expressions in this list."""
  and: [PlayFilter!]

  """Checks for any expressions in this list."""
  or: [PlayFilter!]

  """Negates the expression."""
  not: PlayFilter
}

"""A filter to be used against aggregates of `Play` object types."""
input PlayAggregatesFilter {
  """
  A filter that must pass for the relevant `Play` object to be included within the aggregate.
  """
  filter: PlayFilter

  """Sum aggregate over matching `Play` objects."""
  sum: PlaySumAggregateFilter

  """Distinct count aggregate over matching `Play` objects."""
  distinctCount: PlayDistinctCountAggregateFilter

  """Minimum aggregate over matching `Play` objects."""
  min: PlayMinAggregateFilter

  """Maximum aggregate over matching `Play` objects."""
  max: PlayMaxAggregateFilter

  """Mean average aggregate over matching `Play` objects."""
  average: PlayAverageAggregateFilter

  """Deciles (discrete) aggregate over matching `Play` objects."""
  decilesDisc: PlayDecilesDiscAggregateFilter

  """Sample standard deviation aggregate over matching `Play` objects."""
  stddevSample: PlayStddevSampleAggregateFilter

  """Population standard deviation aggregate over matching `Play` objects."""
  stddevPopulation: PlayStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Play` objects."""
  varianceSample: PlayVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Play` objects."""
  variancePopulation: PlayVariancePopulationAggregateFilter
}

input PlaySumAggregateFilter {
  id: BigIntFilter
  dt: BigFloatFilter
}

input PlayDistinctCountAggregateFilter {
  id: BigIntFilter
  trackId: BigIntFilter
  dt: BigIntFilter
}

input PlayMinAggregateFilter {
  id: IntFilter
  dt: BigIntFilter
}

input PlayMaxAggregateFilter {
  id: IntFilter
  dt: BigIntFilter
}

input PlayAverageAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

input PlayDecilesDiscAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

input PlayStddevSampleAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

input PlayStddevPopulationAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

input PlayVarianceSampleAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

input PlayVariancePopulationAggregateFilter {
  id: BigFloatFilter
  dt: BigFloatFilter
}

"""
A filter to be used against `PlaylistFolder` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistFolderFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `ix` field."""
  ix: IntFilter

  """Filter by the object’s `playlists` relation."""
  playlists: PlaylistFolderToManyPlaylistFilter

  """Some related `playlists` exist."""
  playlistsExist: Boolean

  """Checks for all expressions in this list."""
  and: [PlaylistFolderFilter!]

  """Checks for any expressions in this list."""
  or: [PlaylistFolderFilter!]

  """Negates the expression."""
  not: PlaylistFolderFilter
}

"""
A filter to be used against many `Playlist` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistFolderToManyPlaylistFilter {
  """
  Every related `Playlist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PlaylistFilter

  """
  Some related `Playlist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PlaylistFilter

  """
  No related `Playlist` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PlaylistFilter

  """Aggregates across related `Playlist` match the filter criteria."""
  aggregates: PlaylistAggregatesFilter
}

"""A filter to be used against aggregates of `Playlist` object types."""
input PlaylistAggregatesFilter {
  """
  A filter that must pass for the relevant `Playlist` object to be included within the aggregate.
  """
  filter: PlaylistFilter

  """Sum aggregate over matching `Playlist` objects."""
  sum: PlaylistSumAggregateFilter

  """Distinct count aggregate over matching `Playlist` objects."""
  distinctCount: PlaylistDistinctCountAggregateFilter

  """Minimum aggregate over matching `Playlist` objects."""
  min: PlaylistMinAggregateFilter

  """Maximum aggregate over matching `Playlist` objects."""
  max: PlaylistMaxAggregateFilter

  """Mean average aggregate over matching `Playlist` objects."""
  average: PlaylistAverageAggregateFilter

  """Deciles (discrete) aggregate over matching `Playlist` objects."""
  decilesDisc: PlaylistDecilesDiscAggregateFilter

  """Sample standard deviation aggregate over matching `Playlist` objects."""
  stddevSample: PlaylistStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Playlist` objects.
  """
  stddevPopulation: PlaylistStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Playlist` objects."""
  varianceSample: PlaylistVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Playlist` objects."""
  variancePopulation: PlaylistVariancePopulationAggregateFilter
}

input PlaylistSumAggregateFilter {
  id: BigIntFilter
  playlistFolderId: BigIntFilter
  ix: BigIntFilter
}

input PlaylistDistinctCountAggregateFilter {
  id: BigIntFilter
  playlistFolderId: BigIntFilter
  name: BigIntFilter
  sortCol: BigIntFilter
  sortAsc: BigIntFilter
  ix: BigIntFilter
}

input PlaylistMinAggregateFilter {
  id: IntFilter
  playlistFolderId: IntFilter
  ix: IntFilter
}

input PlaylistMaxAggregateFilter {
  id: IntFilter
  playlistFolderId: IntFilter
  ix: IntFilter
}

input PlaylistAverageAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistDecilesDiscAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistStddevSampleAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistStddevPopulationAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistVarianceSampleAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

input PlaylistVariancePopulationAggregateFilter {
  id: BigFloatFilter
  playlistFolderId: BigFloatFilter
  ix: BigFloatFilter
}

"""A connection to a list of `PlaylistTracksHistory` values."""
type PlaylistTracksHistoriesConnection {
  """A list of `PlaylistTracksHistory` objects."""
  nodes: [PlaylistTracksHistory]!

  """
  A list of edges which contains the `PlaylistTracksHistory` and cursor to aid in pagination.
  """
  edges: [PlaylistTracksHistoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `PlaylistTracksHistory` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlaylistTracksHistoryAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `PlaylistTracksHistory` for these aggregates.
    """
    groupBy: [PlaylistTracksHistoryGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaylistTracksHistoryHavingInput
  ): [PlaylistTracksHistoryAggregates!]
}

type PlaylistTracksHistory {
  historyId: Int!
  playlistId: Int!
  trackId: String!
  ix: Int!

  """
  Reads a single `Playlist` that is related to this `PlaylistTracksHistory`.
  """
  playlist: Playlist

  """
  Reads a single `Track` that is related to this `PlaylistTracksHistory`.
  """
  track: Track
}

"""A `PlaylistTracksHistory` edge in the connection."""
type PlaylistTracksHistoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PlaylistTracksHistory` at the end of the edge."""
  node: PlaylistTracksHistory
}

type PlaylistTracksHistoryAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaylistTracksHistorySumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlaylistTracksHistoryDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlaylistTracksHistoryMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlaylistTracksHistoryMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlaylistTracksHistoryAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlaylistTracksHistoryDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlaylistTracksHistoryStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlaylistTracksHistoryStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlaylistTracksHistoryVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlaylistTracksHistoryVariancePopulationAggregates
}

type PlaylistTracksHistorySumAggregates {
  """Sum of historyId across the matching connection"""
  historyId: BigInt!

  """Sum of playlistId across the matching connection"""
  playlistId: BigInt!

  """Sum of ix across the matching connection"""
  ix: BigInt!
}

type PlaylistTracksHistoryDistinctCountAggregates {
  """Distinct count of historyId across the matching connection"""
  historyId: BigInt

  """Distinct count of playlistId across the matching connection"""
  playlistId: BigInt

  """Distinct count of trackId across the matching connection"""
  trackId: BigInt

  """Distinct count of ix across the matching connection"""
  ix: BigInt
}

type PlaylistTracksHistoryMinAggregates {
  """Minimum of historyId across the matching connection"""
  historyId: Int

  """Minimum of playlistId across the matching connection"""
  playlistId: Int

  """Minimum of ix across the matching connection"""
  ix: Int
}

type PlaylistTracksHistoryMaxAggregates {
  """Maximum of historyId across the matching connection"""
  historyId: Int

  """Maximum of playlistId across the matching connection"""
  playlistId: Int

  """Maximum of ix across the matching connection"""
  ix: Int
}

type PlaylistTracksHistoryAverageAggregates {
  """Mean average of historyId across the matching connection"""
  historyId: BigFloat

  """Mean average of playlistId across the matching connection"""
  playlistId: BigFloat

  """Mean average of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTracksHistoryDecilesDiscAggregates {
  """Deciles (discrete) of historyId across the matching connection"""
  historyId: BigFloat

  """Deciles (discrete) of playlistId across the matching connection"""
  playlistId: BigFloat

  """Deciles (discrete) of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTracksHistoryStddevSampleAggregates {
  """Sample standard deviation of historyId across the matching connection"""
  historyId: BigFloat

  """Sample standard deviation of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTracksHistoryStddevPopulationAggregates {
  """
  Population standard deviation of historyId across the matching connection
  """
  historyId: BigFloat

  """
  Population standard deviation of playlistId across the matching connection
  """
  playlistId: BigFloat

  """Population standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTracksHistoryVarianceSampleAggregates {
  """Sample variance of historyId across the matching connection"""
  historyId: BigFloat

  """Sample variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample variance of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTracksHistoryVariancePopulationAggregates {
  """Population variance of historyId across the matching connection"""
  historyId: BigFloat

  """Population variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Population variance of ix across the matching connection"""
  ix: BigFloat
}

"""
Grouping methods for `PlaylistTracksHistory` for usage during aggregation.
"""
enum PlaylistTracksHistoryGroupBy {
  HISTORY_ID
  PLAYLIST_ID
  TRACK_ID
  IX
}

"""Conditions for `PlaylistTracksHistory` aggregates."""
input PlaylistTracksHistoryHavingInput {
  AND: [PlaylistTracksHistoryHavingInput!]
  OR: [PlaylistTracksHistoryHavingInput!]
  sum: PlaylistTracksHistoryHavingSumInput
  distinctCount: PlaylistTracksHistoryHavingDistinctCountInput
  min: PlaylistTracksHistoryHavingMinInput
  max: PlaylistTracksHistoryHavingMaxInput
  average: PlaylistTracksHistoryHavingAverageInput
  deciles_disc: PlaylistTracksHistoryHavingDecilesDiscInput
  stddevSample: PlaylistTracksHistoryHavingStddevSampleInput
  stddevPopulation: PlaylistTracksHistoryHavingStddevPopulationInput
  varianceSample: PlaylistTracksHistoryHavingVarianceSampleInput
  variancePopulation: PlaylistTracksHistoryHavingVariancePopulationInput
}

input PlaylistTracksHistoryHavingSumInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingDistinctCountInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingMinInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingMaxInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingAverageInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingDecilesDiscInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingStddevSampleInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingStddevPopulationInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingVarianceSampleInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHistoryHavingVariancePopulationInput {
  historyId: HavingIntFilter
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

"""Methods to use when ordering `PlaylistTracksHistory`."""
enum PlaylistTracksHistoriesOrderBy {
  NATURAL
  HISTORY_ID_ASC
  HISTORY_ID_DESC
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  TRACK_ID_ASC
  TRACK_ID_DESC
  IX_ASC
  IX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PLAYLIST_BY_PLAYLIST_ID__ID_ASC
  PLAYLIST_BY_PLAYLIST_ID__ID_DESC
  PLAYLIST_BY_PLAYLIST_ID__PLAYLIST_FOLDER_ID_ASC
  PLAYLIST_BY_PLAYLIST_ID__PLAYLIST_FOLDER_ID_DESC
  PLAYLIST_BY_PLAYLIST_ID__NAME_ASC
  PLAYLIST_BY_PLAYLIST_ID__NAME_DESC
  PLAYLIST_BY_PLAYLIST_ID__SORT_COL_ASC
  PLAYLIST_BY_PLAYLIST_ID__SORT_COL_DESC
  PLAYLIST_BY_PLAYLIST_ID__SORT_ASC_ASC
  PLAYLIST_BY_PLAYLIST_ID__SORT_ASC_DESC
  PLAYLIST_BY_PLAYLIST_ID__IX_ASC
  PLAYLIST_BY_PLAYLIST_ID__IX_DESC
  TRACK_BY_TRACK_ID__ID_ASC
  TRACK_BY_TRACK_ID__ID_DESC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_ASC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_DESC
  TRACK_BY_TRACK_ID__ARTIST_ASC
  TRACK_BY_TRACK_ID__ARTIST_DESC
  TRACK_BY_TRACK_ID__ALBUM_ASC
  TRACK_BY_TRACK_ID__ALBUM_DESC
  TRACK_BY_TRACK_ID__DISC_I_ASC
  TRACK_BY_TRACK_ID__DISC_I_DESC
  TRACK_BY_TRACK_ID__DISC_N_ASC
  TRACK_BY_TRACK_ID__DISC_N_DESC
  TRACK_BY_TRACK_ID__TITLE_ASC
  TRACK_BY_TRACK_ID__TITLE_DESC
  TRACK_BY_TRACK_ID__TRACK_I_ASC
  TRACK_BY_TRACK_ID__TRACK_I_DESC
  TRACK_BY_TRACK_ID__TRACK_N_ASC
  TRACK_BY_TRACK_ID__TRACK_N_DESC
  TRACK_BY_TRACK_ID__DURATION_ASC
  TRACK_BY_TRACK_ID__DURATION_DESC
  TRACK_BY_TRACK_ID__COMPOSER_ASC
  TRACK_BY_TRACK_ID__COMPOSER_DESC
  TRACK_BY_TRACK_ID__GROUPING_ASC
  TRACK_BY_TRACK_ID__GROUPING_DESC
  TRACK_BY_TRACK_ID__RATING_ASC
  TRACK_BY_TRACK_ID__RATING_DESC
  TRACK_BY_TRACK_ID__YEAR_ASC
  TRACK_BY_TRACK_ID__YEAR_DESC
  TRACK_BY_TRACK_ID__GENRE_ASC
  TRACK_BY_TRACK_ID__GENRE_DESC
  TRACK_BY_TRACK_ID__COMPILATION_ASC
  TRACK_BY_TRACK_ID__COMPILATION_DESC
  TRACK_BY_TRACK_ID__COMMENTS_ASC
  TRACK_BY_TRACK_ID__COMMENTS_DESC
  TRACK_BY_TRACK_ID__BITRATE_ASC
  TRACK_BY_TRACK_ID__BITRATE_DESC
  TRACK_BY_TRACK_ID__START_AT_ASC
  TRACK_BY_TRACK_ID__START_AT_DESC
  TRACK_BY_TRACK_ID__STOP_AT_ASC
  TRACK_BY_TRACK_ID__STOP_AT_DESC
  TRACK_BY_TRACK_ID__FILE_SIZE_ASC
  TRACK_BY_TRACK_ID__FILE_SIZE_DESC
  TRACK_BY_TRACK_ID__IX_ASC
  TRACK_BY_TRACK_ID__IX_DESC
  TRACK_BY_TRACK_ID__CREATED_AT_ASC
  TRACK_BY_TRACK_ID__CREATED_AT_DESC
  TRACK_BY_TRACK_ID__UPDATED_AT_ASC
  TRACK_BY_TRACK_ID__UPDATED_AT_DESC
  TRACK_BY_TRACK_ID__GENRE_CAT_ASC
  TRACK_BY_TRACK_ID__GENRE_CAT_DESC
  TRACK_BY_TRACK_ID__GENRE_COLOR_ASC
  TRACK_BY_TRACK_ID__GENRE_COLOR_DESC
  TRACK_BY_TRACK_ID__LAST_PLAYED_ASC
  TRACK_BY_TRACK_ID__LAST_PLAYED_DESC
  TRACK_BY_TRACK_ID__N_PLAYS_ASC
  TRACK_BY_TRACK_ID__N_PLAYS_DESC
}

"""
A condition to be used against `PlaylistTracksHistory` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input PlaylistTracksHistoryCondition {
  """Checks for equality with the object’s `historyId` field."""
  historyId: Int

  """Checks for equality with the object’s `playlistId` field."""
  playlistId: Int

  """Checks for equality with the object’s `trackId` field."""
  trackId: String

  """Checks for equality with the object’s `ix` field."""
  ix: Int
}

"""A connection to a list of `Play` values."""
type PlaysConnection {
  """A list of `Play` objects."""
  nodes: [Play]!

  """
  A list of edges which contains the `Play` and cursor to aid in pagination.
  """
  edges: [PlaysEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Play` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlayAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Play` for these aggregates."""
    groupBy: [PlaysGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaysHavingInput
  ): [PlayAggregates!]
}

type Play {
  id: Int!
  trackId: String!
  dt: BigInt!

  """Reads a single `Track` that is related to this `Play`."""
  track: Track
}

"""A `Play` edge in the connection."""
type PlaysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Play` at the end of the edge."""
  node: Play
}

type PlayAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaySumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlayDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlayMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlayMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlayAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlayDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlayStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlayStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlayVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlayVariancePopulationAggregates
}

type PlaySumAggregates {
  """Sum of id across the matching connection"""
  id: BigInt!

  """Sum of dt across the matching connection"""
  dt: BigFloat!
}

type PlayDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of trackId across the matching connection"""
  trackId: BigInt

  """Distinct count of dt across the matching connection"""
  dt: BigInt
}

type PlayMinAggregates {
  """Minimum of id across the matching connection"""
  id: Int

  """Minimum of dt across the matching connection"""
  dt: BigInt
}

type PlayMaxAggregates {
  """Maximum of id across the matching connection"""
  id: Int

  """Maximum of dt across the matching connection"""
  dt: BigInt
}

type PlayAverageAggregates {
  """Mean average of id across the matching connection"""
  id: BigFloat

  """Mean average of dt across the matching connection"""
  dt: BigFloat
}

type PlayDecilesDiscAggregates {
  """Deciles (discrete) of id across the matching connection"""
  id: BigFloat

  """Deciles (discrete) of dt across the matching connection"""
  dt: BigFloat
}

type PlayStddevSampleAggregates {
  """Sample standard deviation of id across the matching connection"""
  id: BigFloat

  """Sample standard deviation of dt across the matching connection"""
  dt: BigFloat
}

type PlayStddevPopulationAggregates {
  """Population standard deviation of id across the matching connection"""
  id: BigFloat

  """Population standard deviation of dt across the matching connection"""
  dt: BigFloat
}

type PlayVarianceSampleAggregates {
  """Sample variance of id across the matching connection"""
  id: BigFloat

  """Sample variance of dt across the matching connection"""
  dt: BigFloat
}

type PlayVariancePopulationAggregates {
  """Population variance of id across the matching connection"""
  id: BigFloat

  """Population variance of dt across the matching connection"""
  dt: BigFloat
}

"""Grouping methods for `Play` for usage during aggregation."""
enum PlaysGroupBy {
  TRACK_ID
  DT
}

"""Conditions for `Play` aggregates."""
input PlaysHavingInput {
  AND: [PlaysHavingInput!]
  OR: [PlaysHavingInput!]
  sum: PlaysHavingSumInput
  distinctCount: PlaysHavingDistinctCountInput
  min: PlaysHavingMinInput
  max: PlaysHavingMaxInput
  average: PlaysHavingAverageInput
  deciles_disc: PlaysHavingDecilesDiscInput
  stddevSample: PlaysHavingStddevSampleInput
  stddevPopulation: PlaysHavingStddevPopulationInput
  varianceSample: PlaysHavingVarianceSampleInput
  variancePopulation: PlaysHavingVariancePopulationInput
}

input PlaysHavingSumInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingDistinctCountInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingMinInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingMaxInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingAverageInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingDecilesDiscInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingStddevSampleInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingStddevPopulationInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingVarianceSampleInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

input PlaysHavingVariancePopulationInput {
  id: HavingIntFilter
  dt: HavingBigintFilter
}

"""Methods to use when ordering `Play`."""
enum PlaysOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TRACK_ID_ASC
  TRACK_ID_DESC
  DT_ASC
  DT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TRACK_BY_TRACK_ID__ID_ASC
  TRACK_BY_TRACK_ID__ID_DESC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_ASC
  TRACK_BY_TRACK_ID__ALBUM_ARTIST_DESC
  TRACK_BY_TRACK_ID__ARTIST_ASC
  TRACK_BY_TRACK_ID__ARTIST_DESC
  TRACK_BY_TRACK_ID__ALBUM_ASC
  TRACK_BY_TRACK_ID__ALBUM_DESC
  TRACK_BY_TRACK_ID__DISC_I_ASC
  TRACK_BY_TRACK_ID__DISC_I_DESC
  TRACK_BY_TRACK_ID__DISC_N_ASC
  TRACK_BY_TRACK_ID__DISC_N_DESC
  TRACK_BY_TRACK_ID__TITLE_ASC
  TRACK_BY_TRACK_ID__TITLE_DESC
  TRACK_BY_TRACK_ID__TRACK_I_ASC
  TRACK_BY_TRACK_ID__TRACK_I_DESC
  TRACK_BY_TRACK_ID__TRACK_N_ASC
  TRACK_BY_TRACK_ID__TRACK_N_DESC
  TRACK_BY_TRACK_ID__DURATION_ASC
  TRACK_BY_TRACK_ID__DURATION_DESC
  TRACK_BY_TRACK_ID__COMPOSER_ASC
  TRACK_BY_TRACK_ID__COMPOSER_DESC
  TRACK_BY_TRACK_ID__GROUPING_ASC
  TRACK_BY_TRACK_ID__GROUPING_DESC
  TRACK_BY_TRACK_ID__RATING_ASC
  TRACK_BY_TRACK_ID__RATING_DESC
  TRACK_BY_TRACK_ID__YEAR_ASC
  TRACK_BY_TRACK_ID__YEAR_DESC
  TRACK_BY_TRACK_ID__GENRE_ASC
  TRACK_BY_TRACK_ID__GENRE_DESC
  TRACK_BY_TRACK_ID__COMPILATION_ASC
  TRACK_BY_TRACK_ID__COMPILATION_DESC
  TRACK_BY_TRACK_ID__COMMENTS_ASC
  TRACK_BY_TRACK_ID__COMMENTS_DESC
  TRACK_BY_TRACK_ID__BITRATE_ASC
  TRACK_BY_TRACK_ID__BITRATE_DESC
  TRACK_BY_TRACK_ID__START_AT_ASC
  TRACK_BY_TRACK_ID__START_AT_DESC
  TRACK_BY_TRACK_ID__STOP_AT_ASC
  TRACK_BY_TRACK_ID__STOP_AT_DESC
  TRACK_BY_TRACK_ID__FILE_SIZE_ASC
  TRACK_BY_TRACK_ID__FILE_SIZE_DESC
  TRACK_BY_TRACK_ID__IX_ASC
  TRACK_BY_TRACK_ID__IX_DESC
  TRACK_BY_TRACK_ID__CREATED_AT_ASC
  TRACK_BY_TRACK_ID__CREATED_AT_DESC
  TRACK_BY_TRACK_ID__UPDATED_AT_ASC
  TRACK_BY_TRACK_ID__UPDATED_AT_DESC
  TRACK_BY_TRACK_ID__GENRE_CAT_ASC
  TRACK_BY_TRACK_ID__GENRE_CAT_DESC
  TRACK_BY_TRACK_ID__GENRE_COLOR_ASC
  TRACK_BY_TRACK_ID__GENRE_COLOR_DESC
  TRACK_BY_TRACK_ID__LAST_PLAYED_ASC
  TRACK_BY_TRACK_ID__LAST_PLAYED_DESC
  TRACK_BY_TRACK_ID__N_PLAYS_ASC
  TRACK_BY_TRACK_ID__N_PLAYS_DESC
}

"""
A condition to be used against `Play` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PlayCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `trackId` field."""
  trackId: String

  """Checks for equality with the object’s `dt` field."""
  dt: BigInt
}

"""A `PlaylistTrack` edge in the connection."""
type PlaylistTracksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PlaylistTrack` at the end of the edge."""
  node: PlaylistTrack
}

type PlaylistTrackAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaylistTrackSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlaylistTrackDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlaylistTrackMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlaylistTrackMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlaylistTrackAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlaylistTrackDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlaylistTrackStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlaylistTrackStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlaylistTrackVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlaylistTrackVariancePopulationAggregates
}

type PlaylistTrackSumAggregates {
  """Sum of playlistId across the matching connection"""
  playlistId: BigInt!

  """Sum of ix across the matching connection"""
  ix: BigInt!
}

type PlaylistTrackDistinctCountAggregates {
  """Distinct count of playlistId across the matching connection"""
  playlistId: BigInt

  """Distinct count of trackId across the matching connection"""
  trackId: BigInt

  """Distinct count of ix across the matching connection"""
  ix: BigInt
}

type PlaylistTrackMinAggregates {
  """Minimum of playlistId across the matching connection"""
  playlistId: Int

  """Minimum of ix across the matching connection"""
  ix: Int
}

type PlaylistTrackMaxAggregates {
  """Maximum of playlistId across the matching connection"""
  playlistId: Int

  """Maximum of ix across the matching connection"""
  ix: Int
}

type PlaylistTrackAverageAggregates {
  """Mean average of playlistId across the matching connection"""
  playlistId: BigFloat

  """Mean average of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTrackDecilesDiscAggregates {
  """Deciles (discrete) of playlistId across the matching connection"""
  playlistId: BigFloat

  """Deciles (discrete) of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTrackStddevSampleAggregates {
  """Sample standard deviation of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTrackStddevPopulationAggregates {
  """
  Population standard deviation of playlistId across the matching connection
  """
  playlistId: BigFloat

  """Population standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTrackVarianceSampleAggregates {
  """Sample variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample variance of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistTrackVariancePopulationAggregates {
  """Population variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Population variance of ix across the matching connection"""
  ix: BigFloat
}

"""Grouping methods for `PlaylistTrack` for usage during aggregation."""
enum PlaylistTracksGroupBy {
  PLAYLIST_ID
  TRACK_ID
  IX
}

"""Conditions for `PlaylistTrack` aggregates."""
input PlaylistTracksHavingInput {
  AND: [PlaylistTracksHavingInput!]
  OR: [PlaylistTracksHavingInput!]
  sum: PlaylistTracksHavingSumInput
  distinctCount: PlaylistTracksHavingDistinctCountInput
  min: PlaylistTracksHavingMinInput
  max: PlaylistTracksHavingMaxInput
  average: PlaylistTracksHavingAverageInput
  deciles_disc: PlaylistTracksHavingDecilesDiscInput
  stddevSample: PlaylistTracksHavingStddevSampleInput
  stddevPopulation: PlaylistTracksHavingStddevPopulationInput
  varianceSample: PlaylistTracksHavingVarianceSampleInput
  variancePopulation: PlaylistTracksHavingVariancePopulationInput
}

input PlaylistTracksHavingSumInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingDistinctCountInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingMinInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingMaxInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingAverageInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingDecilesDiscInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingStddevSampleInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingStddevPopulationInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingVarianceSampleInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistTracksHavingVariancePopulationInput {
  playlistId: HavingIntFilter
  ix: HavingIntFilter
}

"""A `Playlist` edge in the connection."""
type PlaylistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Playlist` at the end of the edge."""
  node: Playlist
}

type PlaylistAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaylistSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlaylistDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlaylistMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlaylistMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlaylistAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlaylistDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlaylistStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlaylistStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlaylistVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlaylistVariancePopulationAggregates
}

type PlaylistSumAggregates {
  """Sum of id across the matching connection"""
  id: BigInt!

  """Sum of playlistFolderId across the matching connection"""
  playlistFolderId: BigInt!

  """Sum of ix across the matching connection"""
  ix: BigInt!
}

type PlaylistDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of playlistFolderId across the matching connection"""
  playlistFolderId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of sortCol across the matching connection"""
  sortCol: BigInt

  """Distinct count of sortAsc across the matching connection"""
  sortAsc: BigInt

  """Distinct count of ix across the matching connection"""
  ix: BigInt
}

type PlaylistMinAggregates {
  """Minimum of id across the matching connection"""
  id: Int

  """Minimum of playlistFolderId across the matching connection"""
  playlistFolderId: Int

  """Minimum of ix across the matching connection"""
  ix: Int
}

type PlaylistMaxAggregates {
  """Maximum of id across the matching connection"""
  id: Int

  """Maximum of playlistFolderId across the matching connection"""
  playlistFolderId: Int

  """Maximum of ix across the matching connection"""
  ix: Int
}

type PlaylistAverageAggregates {
  """Mean average of id across the matching connection"""
  id: BigFloat

  """Mean average of playlistFolderId across the matching connection"""
  playlistFolderId: BigFloat

  """Mean average of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistDecilesDiscAggregates {
  """Deciles (discrete) of id across the matching connection"""
  id: BigFloat

  """Deciles (discrete) of playlistFolderId across the matching connection"""
  playlistFolderId: BigFloat

  """Deciles (discrete) of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistStddevSampleAggregates {
  """Sample standard deviation of id across the matching connection"""
  id: BigFloat

  """
  Sample standard deviation of playlistFolderId across the matching connection
  """
  playlistFolderId: BigFloat

  """Sample standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistStddevPopulationAggregates {
  """Population standard deviation of id across the matching connection"""
  id: BigFloat

  """
  Population standard deviation of playlistFolderId across the matching connection
  """
  playlistFolderId: BigFloat

  """Population standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistVarianceSampleAggregates {
  """Sample variance of id across the matching connection"""
  id: BigFloat

  """Sample variance of playlistFolderId across the matching connection"""
  playlistFolderId: BigFloat

  """Sample variance of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistVariancePopulationAggregates {
  """Population variance of id across the matching connection"""
  id: BigFloat

  """Population variance of playlistFolderId across the matching connection"""
  playlistFolderId: BigFloat

  """Population variance of ix across the matching connection"""
  ix: BigFloat
}

"""Grouping methods for `Playlist` for usage during aggregation."""
enum PlaylistsGroupBy {
  PLAYLIST_FOLDER_ID
  SORT_COL
  SORT_ASC
  IX
}

"""Conditions for `Playlist` aggregates."""
input PlaylistsHavingInput {
  AND: [PlaylistsHavingInput!]
  OR: [PlaylistsHavingInput!]
  sum: PlaylistsHavingSumInput
  distinctCount: PlaylistsHavingDistinctCountInput
  min: PlaylistsHavingMinInput
  max: PlaylistsHavingMaxInput
  average: PlaylistsHavingAverageInput
  deciles_disc: PlaylistsHavingDecilesDiscInput
  stddevSample: PlaylistsHavingStddevSampleInput
  stddevPopulation: PlaylistsHavingStddevPopulationInput
  varianceSample: PlaylistsHavingVarianceSampleInput
  variancePopulation: PlaylistsHavingVariancePopulationInput
}

input PlaylistsHavingSumInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingDistinctCountInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingMinInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingMaxInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingAverageInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingDecilesDiscInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingStddevSampleInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingStddevPopulationInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingVarianceSampleInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistsHavingVariancePopulationInput {
  id: HavingIntFilter
  playlistFolderId: HavingIntFilter
  ix: HavingIntFilter
}

"""Methods to use when ordering `Playlist`."""
enum PlaylistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PLAYLIST_FOLDER_ID_ASC
  PLAYLIST_FOLDER_ID_DESC
  NAME_ASC
  NAME_DESC
  SORT_COL_ASC
  SORT_COL_DESC
  SORT_ASC_ASC
  SORT_ASC_DESC
  IX_ASC
  IX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__ID_ASC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__ID_DESC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__NAME_ASC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__NAME_DESC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__IX_ASC
  PLAYLIST_FOLDER_BY_PLAYLIST_FOLDER_ID__IX_DESC
  PLAYLIST_TRACKS_BY_PLAYLIST_ID__COUNT_ASC
  PLAYLIST_TRACKS_BY_PLAYLIST_ID__COUNT_DESC
  PLAYLIST_TRACKS_HISTORIES_BY_PLAYLIST_ID__COUNT_ASC
  PLAYLIST_TRACKS_HISTORIES_BY_PLAYLIST_ID__COUNT_DESC
  PLAYLIST_TRACKS_COUNT_ASC
  PLAYLIST_TRACKS_COUNT_DESC
  PLAYLIST_TRACKS_SUM_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_SUM_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_SUM_TRACK_ID_ASC
  PLAYLIST_TRACKS_SUM_TRACK_ID_DESC
  PLAYLIST_TRACKS_SUM_IX_ASC
  PLAYLIST_TRACKS_SUM_IX_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_TRACK_ID_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_TRACK_ID_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_IX_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_IX_DESC
  PLAYLIST_TRACKS_MIN_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_MIN_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_MIN_TRACK_ID_ASC
  PLAYLIST_TRACKS_MIN_TRACK_ID_DESC
  PLAYLIST_TRACKS_MIN_IX_ASC
  PLAYLIST_TRACKS_MIN_IX_DESC
  PLAYLIST_TRACKS_MAX_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_MAX_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_MAX_TRACK_ID_ASC
  PLAYLIST_TRACKS_MAX_TRACK_ID_DESC
  PLAYLIST_TRACKS_MAX_IX_ASC
  PLAYLIST_TRACKS_MAX_IX_DESC
  PLAYLIST_TRACKS_AVERAGE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_AVERAGE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_AVERAGE_TRACK_ID_ASC
  PLAYLIST_TRACKS_AVERAGE_TRACK_ID_DESC
  PLAYLIST_TRACKS_AVERAGE_IX_ASC
  PLAYLIST_TRACKS_AVERAGE_IX_DESC
  PLAYLIST_TRACKS_DECILES_DISC_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_DECILES_DISC_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_DECILES_DISC_TRACK_ID_ASC
  PLAYLIST_TRACKS_DECILES_DISC_TRACK_ID_DESC
  PLAYLIST_TRACKS_DECILES_DISC_IX_ASC
  PLAYLIST_TRACKS_DECILES_DISC_IX_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_IX_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_IX_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_IX_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_COUNT_ASC
  PLAYLIST_TRACKS_HISTORIES_COUNT_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_IX_DESC
}

"""
A condition to be used against `Playlist` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PlaylistCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `playlistFolderId` field."""
  playlistFolderId: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `sortCol` field."""
  sortCol: String

  """Checks for equality with the object’s `sortAsc` field."""
  sortAsc: Boolean

  """Checks for equality with the object’s `ix` field."""
  ix: Int
}

"""A `PlaylistFolder` edge in the connection."""
type PlaylistFoldersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PlaylistFolder` at the end of the edge."""
  node: PlaylistFolder
}

type PlaylistFolderAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaylistFolderSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlaylistFolderDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlaylistFolderMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlaylistFolderMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlaylistFolderAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlaylistFolderDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlaylistFolderStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlaylistFolderStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlaylistFolderVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlaylistFolderVariancePopulationAggregates
}

type PlaylistFolderSumAggregates {
  """Sum of id across the matching connection"""
  id: BigInt!

  """Sum of ix across the matching connection"""
  ix: BigInt!
}

type PlaylistFolderDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of ix across the matching connection"""
  ix: BigInt
}

type PlaylistFolderMinAggregates {
  """Minimum of id across the matching connection"""
  id: Int

  """Minimum of ix across the matching connection"""
  ix: Int
}

type PlaylistFolderMaxAggregates {
  """Maximum of id across the matching connection"""
  id: Int

  """Maximum of ix across the matching connection"""
  ix: Int
}

type PlaylistFolderAverageAggregates {
  """Mean average of id across the matching connection"""
  id: BigFloat

  """Mean average of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistFolderDecilesDiscAggregates {
  """Deciles (discrete) of id across the matching connection"""
  id: BigFloat

  """Deciles (discrete) of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistFolderStddevSampleAggregates {
  """Sample standard deviation of id across the matching connection"""
  id: BigFloat

  """Sample standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistFolderStddevPopulationAggregates {
  """Population standard deviation of id across the matching connection"""
  id: BigFloat

  """Population standard deviation of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistFolderVarianceSampleAggregates {
  """Sample variance of id across the matching connection"""
  id: BigFloat

  """Sample variance of ix across the matching connection"""
  ix: BigFloat
}

type PlaylistFolderVariancePopulationAggregates {
  """Population variance of id across the matching connection"""
  id: BigFloat

  """Population variance of ix across the matching connection"""
  ix: BigFloat
}

"""Grouping methods for `PlaylistFolder` for usage during aggregation."""
enum PlaylistFoldersGroupBy {
  IX
}

"""Conditions for `PlaylistFolder` aggregates."""
input PlaylistFoldersHavingInput {
  AND: [PlaylistFoldersHavingInput!]
  OR: [PlaylistFoldersHavingInput!]
  sum: PlaylistFoldersHavingSumInput
  distinctCount: PlaylistFoldersHavingDistinctCountInput
  min: PlaylistFoldersHavingMinInput
  max: PlaylistFoldersHavingMaxInput
  average: PlaylistFoldersHavingAverageInput
  deciles_disc: PlaylistFoldersHavingDecilesDiscInput
  stddevSample: PlaylistFoldersHavingStddevSampleInput
  stddevPopulation: PlaylistFoldersHavingStddevPopulationInput
  varianceSample: PlaylistFoldersHavingVarianceSampleInput
  variancePopulation: PlaylistFoldersHavingVariancePopulationInput
}

input PlaylistFoldersHavingSumInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingDistinctCountInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingMinInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingMaxInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingAverageInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingDecilesDiscInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingStddevSampleInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingStddevPopulationInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingVarianceSampleInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

input PlaylistFoldersHavingVariancePopulationInput {
  id: HavingIntFilter
  ix: HavingIntFilter
}

"""Methods to use when ordering `PlaylistFolder`."""
enum PlaylistFoldersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  IX_ASC
  IX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PLAYLISTS_BY_PLAYLIST_FOLDER_ID__COUNT_ASC
  PLAYLISTS_BY_PLAYLIST_FOLDER_ID__COUNT_DESC
  PLAYLISTS_COUNT_ASC
  PLAYLISTS_COUNT_DESC
  PLAYLISTS_SUM_ID_ASC
  PLAYLISTS_SUM_ID_DESC
  PLAYLISTS_SUM_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_SUM_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_SUM_NAME_ASC
  PLAYLISTS_SUM_NAME_DESC
  PLAYLISTS_SUM_SORT_COL_ASC
  PLAYLISTS_SUM_SORT_COL_DESC
  PLAYLISTS_SUM_SORT_ASC_ASC
  PLAYLISTS_SUM_SORT_ASC_DESC
  PLAYLISTS_SUM_IX_ASC
  PLAYLISTS_SUM_IX_DESC
  PLAYLISTS_DISTINCT_COUNT_ID_ASC
  PLAYLISTS_DISTINCT_COUNT_ID_DESC
  PLAYLISTS_DISTINCT_COUNT_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_DISTINCT_COUNT_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_DISTINCT_COUNT_NAME_ASC
  PLAYLISTS_DISTINCT_COUNT_NAME_DESC
  PLAYLISTS_DISTINCT_COUNT_SORT_COL_ASC
  PLAYLISTS_DISTINCT_COUNT_SORT_COL_DESC
  PLAYLISTS_DISTINCT_COUNT_SORT_ASC_ASC
  PLAYLISTS_DISTINCT_COUNT_SORT_ASC_DESC
  PLAYLISTS_DISTINCT_COUNT_IX_ASC
  PLAYLISTS_DISTINCT_COUNT_IX_DESC
  PLAYLISTS_MIN_ID_ASC
  PLAYLISTS_MIN_ID_DESC
  PLAYLISTS_MIN_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_MIN_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_MIN_NAME_ASC
  PLAYLISTS_MIN_NAME_DESC
  PLAYLISTS_MIN_SORT_COL_ASC
  PLAYLISTS_MIN_SORT_COL_DESC
  PLAYLISTS_MIN_SORT_ASC_ASC
  PLAYLISTS_MIN_SORT_ASC_DESC
  PLAYLISTS_MIN_IX_ASC
  PLAYLISTS_MIN_IX_DESC
  PLAYLISTS_MAX_ID_ASC
  PLAYLISTS_MAX_ID_DESC
  PLAYLISTS_MAX_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_MAX_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_MAX_NAME_ASC
  PLAYLISTS_MAX_NAME_DESC
  PLAYLISTS_MAX_SORT_COL_ASC
  PLAYLISTS_MAX_SORT_COL_DESC
  PLAYLISTS_MAX_SORT_ASC_ASC
  PLAYLISTS_MAX_SORT_ASC_DESC
  PLAYLISTS_MAX_IX_ASC
  PLAYLISTS_MAX_IX_DESC
  PLAYLISTS_AVERAGE_ID_ASC
  PLAYLISTS_AVERAGE_ID_DESC
  PLAYLISTS_AVERAGE_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_AVERAGE_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_AVERAGE_NAME_ASC
  PLAYLISTS_AVERAGE_NAME_DESC
  PLAYLISTS_AVERAGE_SORT_COL_ASC
  PLAYLISTS_AVERAGE_SORT_COL_DESC
  PLAYLISTS_AVERAGE_SORT_ASC_ASC
  PLAYLISTS_AVERAGE_SORT_ASC_DESC
  PLAYLISTS_AVERAGE_IX_ASC
  PLAYLISTS_AVERAGE_IX_DESC
  PLAYLISTS_DECILES_DISC_ID_ASC
  PLAYLISTS_DECILES_DISC_ID_DESC
  PLAYLISTS_DECILES_DISC_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_DECILES_DISC_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_DECILES_DISC_NAME_ASC
  PLAYLISTS_DECILES_DISC_NAME_DESC
  PLAYLISTS_DECILES_DISC_SORT_COL_ASC
  PLAYLISTS_DECILES_DISC_SORT_COL_DESC
  PLAYLISTS_DECILES_DISC_SORT_ASC_ASC
  PLAYLISTS_DECILES_DISC_SORT_ASC_DESC
  PLAYLISTS_DECILES_DISC_IX_ASC
  PLAYLISTS_DECILES_DISC_IX_DESC
  PLAYLISTS_STDDEV_SAMPLE_ID_ASC
  PLAYLISTS_STDDEV_SAMPLE_ID_DESC
  PLAYLISTS_STDDEV_SAMPLE_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_STDDEV_SAMPLE_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_STDDEV_SAMPLE_NAME_ASC
  PLAYLISTS_STDDEV_SAMPLE_NAME_DESC
  PLAYLISTS_STDDEV_SAMPLE_SORT_COL_ASC
  PLAYLISTS_STDDEV_SAMPLE_SORT_COL_DESC
  PLAYLISTS_STDDEV_SAMPLE_SORT_ASC_ASC
  PLAYLISTS_STDDEV_SAMPLE_SORT_ASC_DESC
  PLAYLISTS_STDDEV_SAMPLE_IX_ASC
  PLAYLISTS_STDDEV_SAMPLE_IX_DESC
  PLAYLISTS_STDDEV_POPULATION_ID_ASC
  PLAYLISTS_STDDEV_POPULATION_ID_DESC
  PLAYLISTS_STDDEV_POPULATION_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_STDDEV_POPULATION_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_STDDEV_POPULATION_NAME_ASC
  PLAYLISTS_STDDEV_POPULATION_NAME_DESC
  PLAYLISTS_STDDEV_POPULATION_SORT_COL_ASC
  PLAYLISTS_STDDEV_POPULATION_SORT_COL_DESC
  PLAYLISTS_STDDEV_POPULATION_SORT_ASC_ASC
  PLAYLISTS_STDDEV_POPULATION_SORT_ASC_DESC
  PLAYLISTS_STDDEV_POPULATION_IX_ASC
  PLAYLISTS_STDDEV_POPULATION_IX_DESC
  PLAYLISTS_VARIANCE_SAMPLE_ID_ASC
  PLAYLISTS_VARIANCE_SAMPLE_ID_DESC
  PLAYLISTS_VARIANCE_SAMPLE_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_VARIANCE_SAMPLE_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_VARIANCE_SAMPLE_NAME_ASC
  PLAYLISTS_VARIANCE_SAMPLE_NAME_DESC
  PLAYLISTS_VARIANCE_SAMPLE_SORT_COL_ASC
  PLAYLISTS_VARIANCE_SAMPLE_SORT_COL_DESC
  PLAYLISTS_VARIANCE_SAMPLE_SORT_ASC_ASC
  PLAYLISTS_VARIANCE_SAMPLE_SORT_ASC_DESC
  PLAYLISTS_VARIANCE_SAMPLE_IX_ASC
  PLAYLISTS_VARIANCE_SAMPLE_IX_DESC
  PLAYLISTS_VARIANCE_POPULATION_ID_ASC
  PLAYLISTS_VARIANCE_POPULATION_ID_DESC
  PLAYLISTS_VARIANCE_POPULATION_PLAYLIST_FOLDER_ID_ASC
  PLAYLISTS_VARIANCE_POPULATION_PLAYLIST_FOLDER_ID_DESC
  PLAYLISTS_VARIANCE_POPULATION_NAME_ASC
  PLAYLISTS_VARIANCE_POPULATION_NAME_DESC
  PLAYLISTS_VARIANCE_POPULATION_SORT_COL_ASC
  PLAYLISTS_VARIANCE_POPULATION_SORT_COL_DESC
  PLAYLISTS_VARIANCE_POPULATION_SORT_ASC_ASC
  PLAYLISTS_VARIANCE_POPULATION_SORT_ASC_DESC
  PLAYLISTS_VARIANCE_POPULATION_IX_ASC
  PLAYLISTS_VARIANCE_POPULATION_IX_DESC
}

"""
A condition to be used against `PlaylistFolder` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PlaylistFolderCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `ix` field."""
  ix: Int
}

"""A connection to a list of `PlaylistStat` values."""
type PlaylistStatsConnection {
  """A list of `PlaylistStat` objects."""
  nodes: [PlaylistStat]!

  """
  A list of edges which contains the `PlaylistStat` and cursor to aid in pagination.
  """
  edges: [PlaylistStatsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PlaylistStat` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PlaylistStatAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `PlaylistStat` for these aggregates."""
    groupBy: [PlaylistStatsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PlaylistStatsHavingInput
  ): [PlaylistStatAggregates!]
}

type PlaylistStat {
  playlistId: Int
  nTracks: Int
  totalTracksDuration: BigInt
}

"""A `PlaylistStat` edge in the connection."""
type PlaylistStatsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PlaylistStat` at the end of the edge."""
  node: PlaylistStat
}

type PlaylistStatAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: PlaylistStatSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PlaylistStatDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: PlaylistStatMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: PlaylistStatMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: PlaylistStatAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: PlaylistStatDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: PlaylistStatStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: PlaylistStatStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: PlaylistStatVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: PlaylistStatVariancePopulationAggregates
}

type PlaylistStatSumAggregates {
  """Sum of playlistId across the matching connection"""
  playlistId: BigInt!

  """Sum of nTracks across the matching connection"""
  nTracks: BigInt!

  """Sum of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigFloat!
}

type PlaylistStatDistinctCountAggregates {
  """Distinct count of playlistId across the matching connection"""
  playlistId: BigInt

  """Distinct count of nTracks across the matching connection"""
  nTracks: BigInt

  """Distinct count of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigInt
}

type PlaylistStatMinAggregates {
  """Minimum of playlistId across the matching connection"""
  playlistId: Int

  """Minimum of nTracks across the matching connection"""
  nTracks: Int

  """Minimum of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigInt
}

type PlaylistStatMaxAggregates {
  """Maximum of playlistId across the matching connection"""
  playlistId: Int

  """Maximum of nTracks across the matching connection"""
  nTracks: Int

  """Maximum of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigInt
}

type PlaylistStatAverageAggregates {
  """Mean average of playlistId across the matching connection"""
  playlistId: BigFloat

  """Mean average of nTracks across the matching connection"""
  nTracks: BigFloat

  """Mean average of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigFloat
}

type PlaylistStatDecilesDiscAggregates {
  """Deciles (discrete) of playlistId across the matching connection"""
  playlistId: BigFloat

  """Deciles (discrete) of nTracks across the matching connection"""
  nTracks: BigFloat

  """
  Deciles (discrete) of totalTracksDuration across the matching connection
  """
  totalTracksDuration: BigFloat
}

type PlaylistStatStddevSampleAggregates {
  """Sample standard deviation of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample standard deviation of nTracks across the matching connection"""
  nTracks: BigFloat

  """
  Sample standard deviation of totalTracksDuration across the matching connection
  """
  totalTracksDuration: BigFloat
}

type PlaylistStatStddevPopulationAggregates {
  """
  Population standard deviation of playlistId across the matching connection
  """
  playlistId: BigFloat

  """
  Population standard deviation of nTracks across the matching connection
  """
  nTracks: BigFloat

  """
  Population standard deviation of totalTracksDuration across the matching connection
  """
  totalTracksDuration: BigFloat
}

type PlaylistStatVarianceSampleAggregates {
  """Sample variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Sample variance of nTracks across the matching connection"""
  nTracks: BigFloat

  """Sample variance of totalTracksDuration across the matching connection"""
  totalTracksDuration: BigFloat
}

type PlaylistStatVariancePopulationAggregates {
  """Population variance of playlistId across the matching connection"""
  playlistId: BigFloat

  """Population variance of nTracks across the matching connection"""
  nTracks: BigFloat

  """
  Population variance of totalTracksDuration across the matching connection
  """
  totalTracksDuration: BigFloat
}

"""Grouping methods for `PlaylistStat` for usage during aggregation."""
enum PlaylistStatsGroupBy {
  PLAYLIST_ID
  N_TRACKS
  TOTAL_TRACKS_DURATION
}

"""Conditions for `PlaylistStat` aggregates."""
input PlaylistStatsHavingInput {
  AND: [PlaylistStatsHavingInput!]
  OR: [PlaylistStatsHavingInput!]
  sum: PlaylistStatsHavingSumInput
  distinctCount: PlaylistStatsHavingDistinctCountInput
  min: PlaylistStatsHavingMinInput
  max: PlaylistStatsHavingMaxInput
  average: PlaylistStatsHavingAverageInput
  deciles_disc: PlaylistStatsHavingDecilesDiscInput
  stddevSample: PlaylistStatsHavingStddevSampleInput
  stddevPopulation: PlaylistStatsHavingStddevPopulationInput
  varianceSample: PlaylistStatsHavingVarianceSampleInput
  variancePopulation: PlaylistStatsHavingVariancePopulationInput
}

input PlaylistStatsHavingSumInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingDistinctCountInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingMinInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingMaxInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingAverageInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingDecilesDiscInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingStddevSampleInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingStddevPopulationInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingVarianceSampleInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

input PlaylistStatsHavingVariancePopulationInput {
  playlistId: HavingIntFilter
  nTracks: HavingIntFilter
  totalTracksDuration: HavingBigintFilter
}

"""Methods to use when ordering `PlaylistStat`."""
enum PlaylistStatsOrderBy {
  NATURAL
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  N_TRACKS_ASC
  N_TRACKS_DESC
  TOTAL_TRACKS_DURATION_ASC
  TOTAL_TRACKS_DURATION_DESC
}

"""
A condition to be used against `PlaylistStat` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PlaylistStatCondition {
  """Checks for equality with the object’s `playlistId` field."""
  playlistId: Int

  """Checks for equality with the object’s `nTracks` field."""
  nTracks: Int

  """Checks for equality with the object’s `totalTracksDuration` field."""
  totalTracksDuration: BigInt
}

"""
A filter to be used against `PlaylistStat` object types. All fields are combined with a logical ‘and.’
"""
input PlaylistStatFilter {
  """Filter by the object’s `playlistId` field."""
  playlistId: IntFilter

  """Filter by the object’s `nTracks` field."""
  nTracks: IntFilter

  """Filter by the object’s `totalTracksDuration` field."""
  totalTracksDuration: BigIntFilter

  """Checks for all expressions in this list."""
  and: [PlaylistStatFilter!]

  """Checks for any expressions in this list."""
  or: [PlaylistStatFilter!]

  """Negates the expression."""
  not: PlaylistStatFilter
}

"""A connection to a list of `Release` values."""
type ReleasesConnection {
  """A list of `Release` objects."""
  nodes: [Release]!

  """
  A list of edges which contains the `Release` and cursor to aid in pagination.
  """
  edges: [ReleasesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Release` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ReleaseAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Release` for these aggregates."""
    groupBy: [ReleasesGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ReleasesHavingInput
  ): [ReleaseAggregates!]
}

type Release {
  id: UUID!
  title: String
  types: [String]
  ackstate: MbAckstates
  releaseDate: BigInt
  createdAt: BigInt
  artistIds: [UUID]
  artistNames: [String]
  artistNamesS: String
}

"""A `Release` edge in the connection."""
type ReleasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Release` at the end of the edge."""
  node: Release
}

type ReleaseAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ReleaseSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ReleaseDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ReleaseMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ReleaseMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ReleaseAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: ReleaseDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ReleaseStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ReleaseStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ReleaseVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ReleaseVariancePopulationAggregates
}

type ReleaseSumAggregates {
  """Sum of releaseDate across the matching connection"""
  releaseDate: BigFloat!

  """Sum of createdAt across the matching connection"""
  createdAt: BigFloat!
}

type ReleaseDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of types across the matching connection"""
  types: BigInt

  """Distinct count of ackstate across the matching connection"""
  ackstate: BigInt

  """Distinct count of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of artistIds across the matching connection"""
  artistIds: BigInt

  """Distinct count of artistNames across the matching connection"""
  artistNames: BigInt

  """Distinct count of artistNamesS across the matching connection"""
  artistNamesS: BigInt
}

type ReleaseMinAggregates {
  """Minimum of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Minimum of createdAt across the matching connection"""
  createdAt: BigInt
}

type ReleaseMaxAggregates {
  """Maximum of releaseDate across the matching connection"""
  releaseDate: BigInt

  """Maximum of createdAt across the matching connection"""
  createdAt: BigInt
}

type ReleaseAverageAggregates {
  """Mean average of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Mean average of createdAt across the matching connection"""
  createdAt: BigFloat
}

type ReleaseDecilesDiscAggregates {
  """Deciles (discrete) of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Deciles (discrete) of createdAt across the matching connection"""
  createdAt: BigFloat
}

type ReleaseStddevSampleAggregates {
  """
  Sample standard deviation of releaseDate across the matching connection
  """
  releaseDate: BigFloat

  """Sample standard deviation of createdAt across the matching connection"""
  createdAt: BigFloat
}

type ReleaseStddevPopulationAggregates {
  """
  Population standard deviation of releaseDate across the matching connection
  """
  releaseDate: BigFloat

  """
  Population standard deviation of createdAt across the matching connection
  """
  createdAt: BigFloat
}

type ReleaseVarianceSampleAggregates {
  """Sample variance of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Sample variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

type ReleaseVariancePopulationAggregates {
  """Population variance of releaseDate across the matching connection"""
  releaseDate: BigFloat

  """Population variance of createdAt across the matching connection"""
  createdAt: BigFloat
}

"""Grouping methods for `Release` for usage during aggregation."""
enum ReleasesGroupBy {
  ID
  TITLE
  TYPES
  ACKSTATE
  RELEASE_DATE
  CREATED_AT
  ARTIST_IDS
  ARTIST_NAMES
  ARTIST_NAMES_S
}

"""Conditions for `Release` aggregates."""
input ReleasesHavingInput {
  AND: [ReleasesHavingInput!]
  OR: [ReleasesHavingInput!]
  sum: ReleasesHavingSumInput
  distinctCount: ReleasesHavingDistinctCountInput
  min: ReleasesHavingMinInput
  max: ReleasesHavingMaxInput
  average: ReleasesHavingAverageInput
  deciles_disc: ReleasesHavingDecilesDiscInput
  stddevSample: ReleasesHavingStddevSampleInput
  stddevPopulation: ReleasesHavingStddevPopulationInput
  varianceSample: ReleasesHavingVarianceSampleInput
  variancePopulation: ReleasesHavingVariancePopulationInput
}

input ReleasesHavingSumInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingDistinctCountInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingMinInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingMaxInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingAverageInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingDecilesDiscInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingStddevSampleInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingStddevPopulationInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingVarianceSampleInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

input ReleasesHavingVariancePopulationInput {
  releaseDate: HavingBigintFilter
  createdAt: HavingBigintFilter
}

"""Methods to use when ordering `Release`."""
enum ReleasesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  TYPES_ASC
  TYPES_DESC
  ACKSTATE_ASC
  ACKSTATE_DESC
  RELEASE_DATE_ASC
  RELEASE_DATE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ARTIST_IDS_ASC
  ARTIST_IDS_DESC
  ARTIST_NAMES_ASC
  ARTIST_NAMES_DESC
  ARTIST_NAMES_S_ASC
  ARTIST_NAMES_S_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Release` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ReleaseCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `types` field."""
  types: [String]

  """Checks for equality with the object’s `ackstate` field."""
  ackstate: MbAckstates

  """Checks for equality with the object’s `releaseDate` field."""
  releaseDate: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: BigInt

  """Checks for equality with the object’s `artistIds` field."""
  artistIds: [UUID]

  """Checks for equality with the object’s `artistNames` field."""
  artistNames: [String]

  """Checks for equality with the object’s `artistNamesS` field."""
  artistNamesS: String
}

"""
A filter to be used against `Release` object types. All fields are combined with a logical ‘and.’
"""
input ReleaseFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `types` field."""
  types: StringListFilter

  """Filter by the object’s `ackstate` field."""
  ackstate: MbAckstatesFilter

  """Filter by the object’s `releaseDate` field."""
  releaseDate: BigIntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: BigIntFilter

  """Filter by the object’s `artistIds` field."""
  artistIds: UUIDListFilter

  """Filter by the object’s `artistNames` field."""
  artistNames: StringListFilter

  """Filter by the object’s `artistNamesS` field."""
  artistNamesS: StringFilter

  """Checks for all expressions in this list."""
  and: [ReleaseFilter!]

  """Checks for any expressions in this list."""
  or: [ReleaseFilter!]

  """Negates the expression."""
  not: ReleaseFilter
}

"""
A filter to be used against UUID List fields. All fields are combined with a logical ‘and.’
"""
input UUIDListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [UUID]

  """Not equal to the specified value."""
  notEqualTo: [UUID]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [UUID]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [UUID]

  """Less than the specified value."""
  lessThan: [UUID]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [UUID]

  """Greater than the specified value."""
  greaterThan: [UUID]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [UUID]

  """Contains the specified list of values."""
  contains: [UUID]

  """Contained by the specified list of values."""
  containedBy: [UUID]

  """Overlaps the specified list of values."""
  overlaps: [UUID]

  """Any array item is equal to the specified value."""
  anyEqualTo: UUID

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: UUID

  """Any array item is less than the specified value."""
  anyLessThan: UUID

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: UUID

  """Any array item is greater than the specified value."""
  anyGreaterThan: UUID

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: UUID
}

"""A connection to a list of `StarredStat` values."""
type StarredStatsConnection {
  """A list of `StarredStat` objects."""
  nodes: [StarredStat]!

  """
  A list of edges which contains the `StarredStat` and cursor to aid in pagination.
  """
  edges: [StarredStatsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StarredStat` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: StarredStatAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `StarredStat` for these aggregates."""
    groupBy: [StarredStatsGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: StarredStatsHavingInput
  ): [StarredStatAggregates!]
}

type StarredStat {
  rating: Int
  genreCat: String
  duration: BigInt
}

"""A `StarredStat` edge in the connection."""
type StarredStatsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StarredStat` at the end of the edge."""
  node: StarredStat
}

type StarredStatAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: StarredStatSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: StarredStatDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: StarredStatMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: StarredStatMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: StarredStatAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: StarredStatDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: StarredStatStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: StarredStatStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: StarredStatVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: StarredStatVariancePopulationAggregates
}

type StarredStatSumAggregates {
  """Sum of rating across the matching connection"""
  rating: BigInt!

  """Sum of duration across the matching connection"""
  duration: BigFloat!
}

type StarredStatDistinctCountAggregates {
  """Distinct count of rating across the matching connection"""
  rating: BigInt

  """Distinct count of genreCat across the matching connection"""
  genreCat: BigInt

  """Distinct count of duration across the matching connection"""
  duration: BigInt
}

type StarredStatMinAggregates {
  """Minimum of rating across the matching connection"""
  rating: Int

  """Minimum of duration across the matching connection"""
  duration: BigInt
}

type StarredStatMaxAggregates {
  """Maximum of rating across the matching connection"""
  rating: Int

  """Maximum of duration across the matching connection"""
  duration: BigInt
}

type StarredStatAverageAggregates {
  """Mean average of rating across the matching connection"""
  rating: BigFloat

  """Mean average of duration across the matching connection"""
  duration: BigFloat
}

type StarredStatDecilesDiscAggregates {
  """Deciles (discrete) of rating across the matching connection"""
  rating: BigFloat

  """Deciles (discrete) of duration across the matching connection"""
  duration: BigFloat
}

type StarredStatStddevSampleAggregates {
  """Sample standard deviation of rating across the matching connection"""
  rating: BigFloat

  """Sample standard deviation of duration across the matching connection"""
  duration: BigFloat
}

type StarredStatStddevPopulationAggregates {
  """Population standard deviation of rating across the matching connection"""
  rating: BigFloat

  """
  Population standard deviation of duration across the matching connection
  """
  duration: BigFloat
}

type StarredStatVarianceSampleAggregates {
  """Sample variance of rating across the matching connection"""
  rating: BigFloat

  """Sample variance of duration across the matching connection"""
  duration: BigFloat
}

type StarredStatVariancePopulationAggregates {
  """Population variance of rating across the matching connection"""
  rating: BigFloat

  """Population variance of duration across the matching connection"""
  duration: BigFloat
}

"""Grouping methods for `StarredStat` for usage during aggregation."""
enum StarredStatsGroupBy {
  RATING
  GENRE_CAT
  DURATION
}

"""Conditions for `StarredStat` aggregates."""
input StarredStatsHavingInput {
  AND: [StarredStatsHavingInput!]
  OR: [StarredStatsHavingInput!]
  sum: StarredStatsHavingSumInput
  distinctCount: StarredStatsHavingDistinctCountInput
  min: StarredStatsHavingMinInput
  max: StarredStatsHavingMaxInput
  average: StarredStatsHavingAverageInput
  deciles_disc: StarredStatsHavingDecilesDiscInput
  stddevSample: StarredStatsHavingStddevSampleInput
  stddevPopulation: StarredStatsHavingStddevPopulationInput
  varianceSample: StarredStatsHavingVarianceSampleInput
  variancePopulation: StarredStatsHavingVariancePopulationInput
}

input StarredStatsHavingSumInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingDistinctCountInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingMinInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingMaxInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingAverageInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingDecilesDiscInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingStddevSampleInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingStddevPopulationInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingVarianceSampleInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

input StarredStatsHavingVariancePopulationInput {
  rating: HavingIntFilter
  duration: HavingBigintFilter
}

"""Methods to use when ordering `StarredStat`."""
enum StarredStatsOrderBy {
  NATURAL
  RATING_ASC
  RATING_DESC
  GENRE_CAT_ASC
  GENRE_CAT_DESC
  DURATION_ASC
  DURATION_DESC
}

"""
A condition to be used against `StarredStat` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input StarredStatCondition {
  """Checks for equality with the object’s `rating` field."""
  rating: Int

  """Checks for equality with the object’s `genreCat` field."""
  genreCat: String

  """Checks for equality with the object’s `duration` field."""
  duration: BigInt
}

"""
A filter to be used against `StarredStat` object types. All fields are combined with a logical ‘and.’
"""
input StarredStatFilter {
  """Filter by the object’s `rating` field."""
  rating: IntFilter

  """Filter by the object’s `genreCat` field."""
  genreCat: StringFilter

  """Filter by the object’s `duration` field."""
  duration: BigIntFilter

  """Checks for all expressions in this list."""
  and: [StarredStatFilter!]

  """Checks for any expressions in this list."""
  or: [StarredStatFilter!]

  """Negates the expression."""
  not: StarredStatFilter
}

"""A connection to a list of `Track` values."""
type TracksConnection {
  """A list of `Track` objects."""
  nodes: [Track]!

  """
  A list of edges which contains the `Track` and cursor to aid in pagination.
  """
  edges: [TracksEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Track` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TrackAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Track` for these aggregates."""
    groupBy: [TracksGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TracksHavingInput
  ): [TrackAggregates!]
}

"""A `Track` edge in the connection."""
type TracksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Track` at the end of the edge."""
  node: Track
}

type TrackAggregates {
  keys: [String!]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TrackSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TrackDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TrackMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TrackMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TrackAverageAggregates

  """
  Deciles (discrete) aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  deciles_disc: TrackDecilesDiscAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TrackStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TrackStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TrackVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TrackVariancePopulationAggregates
}

type TrackSumAggregates {
  """Sum of discI across the matching connection"""
  discI: BigInt!

  """Sum of discN across the matching connection"""
  discN: BigInt!

  """Sum of trackI across the matching connection"""
  trackI: BigInt!

  """Sum of trackN across the matching connection"""
  trackN: BigInt!

  """Sum of duration across the matching connection"""
  duration: BigInt!

  """Sum of rating across the matching connection"""
  rating: BigInt!

  """Sum of year across the matching connection"""
  year: BigInt!

  """Sum of bitrate across the matching connection"""
  bitrate: BigInt!

  """Sum of startAt across the matching connection"""
  startAt: BigInt!

  """Sum of stopAt across the matching connection"""
  stopAt: BigInt!

  """Sum of fileSize across the matching connection"""
  fileSize: BigInt!

  """Sum of ix across the matching connection"""
  ix: BigInt!

  """Sum of createdAt across the matching connection"""
  createdAt: BigFloat!

  """Sum of updatedAt across the matching connection"""
  updatedAt: BigFloat!

  """Sum of this field across the matching connection."""
  lastPlayed: BigFloat

  """Sum of this field across the matching connection."""
  nPlays: BigInt
}

type TrackDistinctCountAggregates {
  """Distinct count of id across the matching connection"""
  id: BigInt

  """Distinct count of albumArtist across the matching connection"""
  albumArtist: BigInt

  """Distinct count of artist across the matching connection"""
  artist: BigInt

  """Distinct count of album across the matching connection"""
  album: BigInt

  """Distinct count of discI across the matching connection"""
  discI: BigInt

  """Distinct count of discN across the matching connection"""
  discN: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of trackI across the matching connection"""
  trackI: BigInt

  """Distinct count of trackN across the matching connection"""
  trackN: BigInt

  """Distinct count of duration across the matching connection"""
  duration: BigInt

  """Distinct count of composer across the matching connection"""
  composer: BigInt

  """Distinct count of grouping across the matching connection"""
  grouping: BigInt

  """Distinct count of rating across the matching connection"""
  rating: BigInt

  """Distinct count of year across the matching connection"""
  year: BigInt

  """Distinct count of genre across the matching connection"""
  genre: BigInt

  """Distinct count of compilation across the matching connection"""
  compilation: BigInt

  """Distinct count of comments across the matching connection"""
  comments: BigInt

  """Distinct count of bitrate across the matching connection"""
  bitrate: BigInt

  """Distinct count of startAt across the matching connection"""
  startAt: BigInt

  """Distinct count of stopAt across the matching connection"""
  stopAt: BigInt

  """Distinct count of fileSize across the matching connection"""
  fileSize: BigInt

  """Distinct count of ix across the matching connection"""
  ix: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of this field across the matching connection."""
  genreCat: BigInt

  """Distinct count of this field across the matching connection."""
  genreColor: BigInt

  """Distinct count of this field across the matching connection."""
  lastPlayed: BigInt

  """Distinct count of this field across the matching connection."""
  nPlays: BigInt
}

type TrackMinAggregates {
  """Minimum of discI across the matching connection"""
  discI: Int

  """Minimum of discN across the matching connection"""
  discN: Int

  """Minimum of trackI across the matching connection"""
  trackI: Int

  """Minimum of trackN across the matching connection"""
  trackN: Int

  """Minimum of duration across the matching connection"""
  duration: Int

  """Minimum of rating across the matching connection"""
  rating: Int

  """Minimum of year across the matching connection"""
  year: Int

  """Minimum of bitrate across the matching connection"""
  bitrate: Int

  """Minimum of startAt across the matching connection"""
  startAt: Int

  """Minimum of stopAt across the matching connection"""
  stopAt: Int

  """Minimum of fileSize across the matching connection"""
  fileSize: Int

  """Minimum of ix across the matching connection"""
  ix: Int

  """Minimum of createdAt across the matching connection"""
  createdAt: BigInt

  """Minimum of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Minimum of this field across the matching connection."""
  lastPlayed: BigInt

  """Minimum of this field across the matching connection."""
  nPlays: Int
}

type TrackMaxAggregates {
  """Maximum of discI across the matching connection"""
  discI: Int

  """Maximum of discN across the matching connection"""
  discN: Int

  """Maximum of trackI across the matching connection"""
  trackI: Int

  """Maximum of trackN across the matching connection"""
  trackN: Int

  """Maximum of duration across the matching connection"""
  duration: Int

  """Maximum of rating across the matching connection"""
  rating: Int

  """Maximum of year across the matching connection"""
  year: Int

  """Maximum of bitrate across the matching connection"""
  bitrate: Int

  """Maximum of startAt across the matching connection"""
  startAt: Int

  """Maximum of stopAt across the matching connection"""
  stopAt: Int

  """Maximum of fileSize across the matching connection"""
  fileSize: Int

  """Maximum of ix across the matching connection"""
  ix: Int

  """Maximum of createdAt across the matching connection"""
  createdAt: BigInt

  """Maximum of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Maximum of this field across the matching connection."""
  lastPlayed: BigInt

  """Maximum of this field across the matching connection."""
  nPlays: Int
}

type TrackAverageAggregates {
  """Mean average of discI across the matching connection"""
  discI: BigFloat

  """Mean average of discN across the matching connection"""
  discN: BigFloat

  """Mean average of trackI across the matching connection"""
  trackI: BigFloat

  """Mean average of trackN across the matching connection"""
  trackN: BigFloat

  """Mean average of duration across the matching connection"""
  duration: BigFloat

  """Mean average of rating across the matching connection"""
  rating: BigFloat

  """Mean average of year across the matching connection"""
  year: BigFloat

  """Mean average of bitrate across the matching connection"""
  bitrate: BigFloat

  """Mean average of startAt across the matching connection"""
  startAt: BigFloat

  """Mean average of stopAt across the matching connection"""
  stopAt: BigFloat

  """Mean average of fileSize across the matching connection"""
  fileSize: BigFloat

  """Mean average of ix across the matching connection"""
  ix: BigFloat

  """Mean average of createdAt across the matching connection"""
  createdAt: BigFloat

  """Mean average of updatedAt across the matching connection"""
  updatedAt: BigFloat

  """Mean average of this field across the matching connection."""
  lastPlayed: BigFloat

  """Mean average of this field across the matching connection."""
  nPlays: BigFloat
}

type TrackDecilesDiscAggregates {
  """Deciles (discrete) of discI across the matching connection"""
  discI: BigFloat

  """Deciles (discrete) of discN across the matching connection"""
  discN: BigFloat

  """Deciles (discrete) of trackI across the matching connection"""
  trackI: BigFloat

  """Deciles (discrete) of trackN across the matching connection"""
  trackN: BigFloat

  """Deciles (discrete) of duration across the matching connection"""
  duration: BigFloat

  """Deciles (discrete) of rating across the matching connection"""
  rating: BigFloat

  """Deciles (discrete) of year across the matching connection"""
  year: BigFloat

  """Deciles (discrete) of bitrate across the matching connection"""
  bitrate: BigFloat

  """Deciles (discrete) of startAt across the matching connection"""
  startAt: BigFloat

  """Deciles (discrete) of stopAt across the matching connection"""
  stopAt: BigFloat

  """Deciles (discrete) of fileSize across the matching connection"""
  fileSize: BigFloat

  """Deciles (discrete) of ix across the matching connection"""
  ix: BigFloat

  """Deciles (discrete) of createdAt across the matching connection"""
  createdAt: BigFloat

  """Deciles (discrete) of updatedAt across the matching connection"""
  updatedAt: BigFloat

  """Deciles (discrete) of this field across the matching connection."""
  lastPlayed: BigFloat

  """Deciles (discrete) of this field across the matching connection."""
  nPlays: BigFloat
}

type TrackStddevSampleAggregates {
  """Sample standard deviation of discI across the matching connection"""
  discI: BigFloat

  """Sample standard deviation of discN across the matching connection"""
  discN: BigFloat

  """Sample standard deviation of trackI across the matching connection"""
  trackI: BigFloat

  """Sample standard deviation of trackN across the matching connection"""
  trackN: BigFloat

  """Sample standard deviation of duration across the matching connection"""
  duration: BigFloat

  """Sample standard deviation of rating across the matching connection"""
  rating: BigFloat

  """Sample standard deviation of year across the matching connection"""
  year: BigFloat

  """Sample standard deviation of bitrate across the matching connection"""
  bitrate: BigFloat

  """Sample standard deviation of startAt across the matching connection"""
  startAt: BigFloat

  """Sample standard deviation of stopAt across the matching connection"""
  stopAt: BigFloat

  """Sample standard deviation of fileSize across the matching connection"""
  fileSize: BigFloat

  """Sample standard deviation of ix across the matching connection"""
  ix: BigFloat

  """Sample standard deviation of createdAt across the matching connection"""
  createdAt: BigFloat

  """Sample standard deviation of updatedAt across the matching connection"""
  updatedAt: BigFloat

  """
  Sample standard deviation of this field across the matching connection.
  """
  lastPlayed: BigFloat

  """
  Sample standard deviation of this field across the matching connection.
  """
  nPlays: BigFloat
}

type TrackStddevPopulationAggregates {
  """Population standard deviation of discI across the matching connection"""
  discI: BigFloat

  """Population standard deviation of discN across the matching connection"""
  discN: BigFloat

  """Population standard deviation of trackI across the matching connection"""
  trackI: BigFloat

  """Population standard deviation of trackN across the matching connection"""
  trackN: BigFloat

  """
  Population standard deviation of duration across the matching connection
  """
  duration: BigFloat

  """Population standard deviation of rating across the matching connection"""
  rating: BigFloat

  """Population standard deviation of year across the matching connection"""
  year: BigFloat

  """
  Population standard deviation of bitrate across the matching connection
  """
  bitrate: BigFloat

  """
  Population standard deviation of startAt across the matching connection
  """
  startAt: BigFloat

  """Population standard deviation of stopAt across the matching connection"""
  stopAt: BigFloat

  """
  Population standard deviation of fileSize across the matching connection
  """
  fileSize: BigFloat

  """Population standard deviation of ix across the matching connection"""
  ix: BigFloat

  """
  Population standard deviation of createdAt across the matching connection
  """
  createdAt: BigFloat

  """
  Population standard deviation of updatedAt across the matching connection
  """
  updatedAt: BigFloat

  """
  Population standard deviation of this field across the matching connection.
  """
  lastPlayed: BigFloat

  """
  Population standard deviation of this field across the matching connection.
  """
  nPlays: BigFloat
}

type TrackVarianceSampleAggregates {
  """Sample variance of discI across the matching connection"""
  discI: BigFloat

  """Sample variance of discN across the matching connection"""
  discN: BigFloat

  """Sample variance of trackI across the matching connection"""
  trackI: BigFloat

  """Sample variance of trackN across the matching connection"""
  trackN: BigFloat

  """Sample variance of duration across the matching connection"""
  duration: BigFloat

  """Sample variance of rating across the matching connection"""
  rating: BigFloat

  """Sample variance of year across the matching connection"""
  year: BigFloat

  """Sample variance of bitrate across the matching connection"""
  bitrate: BigFloat

  """Sample variance of startAt across the matching connection"""
  startAt: BigFloat

  """Sample variance of stopAt across the matching connection"""
  stopAt: BigFloat

  """Sample variance of fileSize across the matching connection"""
  fileSize: BigFloat

  """Sample variance of ix across the matching connection"""
  ix: BigFloat

  """Sample variance of createdAt across the matching connection"""
  createdAt: BigFloat

  """Sample variance of updatedAt across the matching connection"""
  updatedAt: BigFloat

  """Sample variance of this field across the matching connection."""
  lastPlayed: BigFloat

  """Sample variance of this field across the matching connection."""
  nPlays: BigFloat
}

type TrackVariancePopulationAggregates {
  """Population variance of discI across the matching connection"""
  discI: BigFloat

  """Population variance of discN across the matching connection"""
  discN: BigFloat

  """Population variance of trackI across the matching connection"""
  trackI: BigFloat

  """Population variance of trackN across the matching connection"""
  trackN: BigFloat

  """Population variance of duration across the matching connection"""
  duration: BigFloat

  """Population variance of rating across the matching connection"""
  rating: BigFloat

  """Population variance of year across the matching connection"""
  year: BigFloat

  """Population variance of bitrate across the matching connection"""
  bitrate: BigFloat

  """Population variance of startAt across the matching connection"""
  startAt: BigFloat

  """Population variance of stopAt across the matching connection"""
  stopAt: BigFloat

  """Population variance of fileSize across the matching connection"""
  fileSize: BigFloat

  """Population variance of ix across the matching connection"""
  ix: BigFloat

  """Population variance of createdAt across the matching connection"""
  createdAt: BigFloat

  """Population variance of updatedAt across the matching connection"""
  updatedAt: BigFloat

  """Population variance of this field across the matching connection."""
  lastPlayed: BigFloat

  """Population variance of this field across the matching connection."""
  nPlays: BigFloat
}

"""Grouping methods for `Track` for usage during aggregation."""
enum TracksGroupBy {
  ALBUM_ARTIST
  ARTIST
  ALBUM
  DISC_I
  DISC_N
  TITLE
  TRACK_I
  TRACK_N
  DURATION
  COMPOSER
  GROUPING
  RATING
  YEAR
  GENRE
  COMPILATION
  COMMENTS
  BITRATE
  START_AT
  STOP_AT
  FILE_SIZE
  IX
  CREATED_AT
  UPDATED_AT
}

"""Conditions for `Track` aggregates."""
input TracksHavingInput {
  AND: [TracksHavingInput!]
  OR: [TracksHavingInput!]
  sum: TracksHavingSumInput
  distinctCount: TracksHavingDistinctCountInput
  min: TracksHavingMinInput
  max: TracksHavingMaxInput
  average: TracksHavingAverageInput
  deciles_disc: TracksHavingDecilesDiscInput
  stddevSample: TracksHavingStddevSampleInput
  stddevPopulation: TracksHavingStddevPopulationInput
  varianceSample: TracksHavingVarianceSampleInput
  variancePopulation: TracksHavingVariancePopulationInput
}

input TracksHavingSumInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingSumTracksLastPlayedInput
  nPlays: TracksHavingSumTracksNPlaysInput
}

input TracksHavingSumTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingSumTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingDistinctCountInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingDistinctCountTracksLastPlayedInput
  nPlays: TracksHavingDistinctCountTracksNPlaysInput
}

input TracksHavingDistinctCountTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingDistinctCountTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingMinInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingMinTracksLastPlayedInput
  nPlays: TracksHavingMinTracksNPlaysInput
}

input TracksHavingMinTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingMinTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingMaxInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingMaxTracksLastPlayedInput
  nPlays: TracksHavingMaxTracksNPlaysInput
}

input TracksHavingMaxTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingMaxTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingAverageInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingAverageTracksLastPlayedInput
  nPlays: TracksHavingAverageTracksNPlaysInput
}

input TracksHavingAverageTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingAverageTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingDecilesDiscInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingDecilesDiscTracksLastPlayedInput
  nPlays: TracksHavingDecilesDiscTracksNPlaysInput
}

input TracksHavingDecilesDiscTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingDecilesDiscTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingStddevSampleInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingStddevSampleTracksLastPlayedInput
  nPlays: TracksHavingStddevSampleTracksNPlaysInput
}

input TracksHavingStddevSampleTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingStddevSampleTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingStddevPopulationInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingStddevPopulationTracksLastPlayedInput
  nPlays: TracksHavingStddevPopulationTracksNPlaysInput
}

input TracksHavingStddevPopulationTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingStddevPopulationTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingVarianceSampleInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingVarianceSampleTracksLastPlayedInput
  nPlays: TracksHavingVarianceSampleTracksNPlaysInput
}

input TracksHavingVarianceSampleTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingVarianceSampleTracksNPlaysInput {
  filter: HavingIntFilter
}

input TracksHavingVariancePopulationInput {
  discI: HavingIntFilter
  discN: HavingIntFilter
  trackI: HavingIntFilter
  trackN: HavingIntFilter
  duration: HavingIntFilter
  rating: HavingIntFilter
  year: HavingIntFilter
  bitrate: HavingIntFilter
  startAt: HavingIntFilter
  stopAt: HavingIntFilter
  fileSize: HavingIntFilter
  ix: HavingIntFilter
  createdAt: HavingBigintFilter
  updatedAt: HavingBigintFilter
  lastPlayed: TracksHavingVariancePopulationTracksLastPlayedInput
  nPlays: TracksHavingVariancePopulationTracksNPlaysInput
}

input TracksHavingVariancePopulationTracksLastPlayedInput {
  filter: HavingBigintFilter
}

input TracksHavingVariancePopulationTracksNPlaysInput {
  filter: HavingIntFilter
}

"""Methods to use when ordering `Track`."""
enum TracksOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ALBUM_ARTIST_ASC
  ALBUM_ARTIST_DESC
  ARTIST_ASC
  ARTIST_DESC
  ALBUM_ASC
  ALBUM_DESC
  DISC_I_ASC
  DISC_I_DESC
  DISC_N_ASC
  DISC_N_DESC
  TITLE_ASC
  TITLE_DESC
  TRACK_I_ASC
  TRACK_I_DESC
  TRACK_N_ASC
  TRACK_N_DESC
  DURATION_ASC
  DURATION_DESC
  COMPOSER_ASC
  COMPOSER_DESC
  GROUPING_ASC
  GROUPING_DESC
  RATING_ASC
  RATING_DESC
  YEAR_ASC
  YEAR_DESC
  GENRE_ASC
  GENRE_DESC
  COMPILATION_ASC
  COMPILATION_DESC
  COMMENTS_ASC
  COMMENTS_DESC
  BITRATE_ASC
  BITRATE_DESC
  START_AT_ASC
  START_AT_DESC
  STOP_AT_ASC
  STOP_AT_DESC
  FILE_SIZE_ASC
  FILE_SIZE_DESC
  IX_ASC
  IX_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  GENRE_CAT_ASC
  GENRE_CAT_DESC
  GENRE_COLOR_ASC
  GENRE_COLOR_DESC
  LAST_PLAYED_ASC
  LAST_PLAYED_DESC
  N_PLAYS_ASC
  N_PLAYS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PLAYLIST_TRACKS_BY_TRACK_ID__COUNT_ASC
  PLAYLIST_TRACKS_BY_TRACK_ID__COUNT_DESC
  PLAYLIST_TRACKS_HISTORIES_BY_TRACK_ID__COUNT_ASC
  PLAYLIST_TRACKS_HISTORIES_BY_TRACK_ID__COUNT_DESC
  PLAYS_BY_TRACK_ID__COUNT_ASC
  PLAYS_BY_TRACK_ID__COUNT_DESC
  PLAYLIST_TRACKS_COUNT_ASC
  PLAYLIST_TRACKS_COUNT_DESC
  PLAYLIST_TRACKS_SUM_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_SUM_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_SUM_TRACK_ID_ASC
  PLAYLIST_TRACKS_SUM_TRACK_ID_DESC
  PLAYLIST_TRACKS_SUM_IX_ASC
  PLAYLIST_TRACKS_SUM_IX_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_TRACK_ID_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_TRACK_ID_DESC
  PLAYLIST_TRACKS_DISTINCT_COUNT_IX_ASC
  PLAYLIST_TRACKS_DISTINCT_COUNT_IX_DESC
  PLAYLIST_TRACKS_MIN_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_MIN_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_MIN_TRACK_ID_ASC
  PLAYLIST_TRACKS_MIN_TRACK_ID_DESC
  PLAYLIST_TRACKS_MIN_IX_ASC
  PLAYLIST_TRACKS_MIN_IX_DESC
  PLAYLIST_TRACKS_MAX_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_MAX_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_MAX_TRACK_ID_ASC
  PLAYLIST_TRACKS_MAX_TRACK_ID_DESC
  PLAYLIST_TRACKS_MAX_IX_ASC
  PLAYLIST_TRACKS_MAX_IX_DESC
  PLAYLIST_TRACKS_AVERAGE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_AVERAGE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_AVERAGE_TRACK_ID_ASC
  PLAYLIST_TRACKS_AVERAGE_TRACK_ID_DESC
  PLAYLIST_TRACKS_AVERAGE_IX_ASC
  PLAYLIST_TRACKS_AVERAGE_IX_DESC
  PLAYLIST_TRACKS_DECILES_DISC_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_DECILES_DISC_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_DECILES_DISC_TRACK_ID_ASC
  PLAYLIST_TRACKS_DECILES_DISC_TRACK_ID_DESC
  PLAYLIST_TRACKS_DECILES_DISC_IX_ASC
  PLAYLIST_TRACKS_DECILES_DISC_IX_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_STDDEV_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_STDDEV_POPULATION_IX_ASC
  PLAYLIST_TRACKS_STDDEV_POPULATION_IX_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_VARIANCE_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_IX_ASC
  PLAYLIST_TRACKS_VARIANCE_POPULATION_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_COUNT_ASC
  PLAYLIST_TRACKS_HISTORIES_COUNT_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_SUM_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_SUM_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_DISTINCT_COUNT_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MIN_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_MIN_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_MAX_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_MAX_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_AVERAGE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_DECILES_DISC_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_STDDEV_POPULATION_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_SAMPLE_IX_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_HISTORY_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_HISTORY_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_PLAYLIST_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_PLAYLIST_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_TRACK_ID_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_TRACK_ID_DESC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_IX_ASC
  PLAYLIST_TRACKS_HISTORIES_VARIANCE_POPULATION_IX_DESC
  PLAYS_COUNT_ASC
  PLAYS_COUNT_DESC
  PLAYS_SUM_ID_ASC
  PLAYS_SUM_ID_DESC
  PLAYS_SUM_TRACK_ID_ASC
  PLAYS_SUM_TRACK_ID_DESC
  PLAYS_SUM_DT_ASC
  PLAYS_SUM_DT_DESC
  PLAYS_DISTINCT_COUNT_ID_ASC
  PLAYS_DISTINCT_COUNT_ID_DESC
  PLAYS_DISTINCT_COUNT_TRACK_ID_ASC
  PLAYS_DISTINCT_COUNT_TRACK_ID_DESC
  PLAYS_DISTINCT_COUNT_DT_ASC
  PLAYS_DISTINCT_COUNT_DT_DESC
  PLAYS_MIN_ID_ASC
  PLAYS_MIN_ID_DESC
  PLAYS_MIN_TRACK_ID_ASC
  PLAYS_MIN_TRACK_ID_DESC
  PLAYS_MIN_DT_ASC
  PLAYS_MIN_DT_DESC
  PLAYS_MAX_ID_ASC
  PLAYS_MAX_ID_DESC
  PLAYS_MAX_TRACK_ID_ASC
  PLAYS_MAX_TRACK_ID_DESC
  PLAYS_MAX_DT_ASC
  PLAYS_MAX_DT_DESC
  PLAYS_AVERAGE_ID_ASC
  PLAYS_AVERAGE_ID_DESC
  PLAYS_AVERAGE_TRACK_ID_ASC
  PLAYS_AVERAGE_TRACK_ID_DESC
  PLAYS_AVERAGE_DT_ASC
  PLAYS_AVERAGE_DT_DESC
  PLAYS_DECILES_DISC_ID_ASC
  PLAYS_DECILES_DISC_ID_DESC
  PLAYS_DECILES_DISC_TRACK_ID_ASC
  PLAYS_DECILES_DISC_TRACK_ID_DESC
  PLAYS_DECILES_DISC_DT_ASC
  PLAYS_DECILES_DISC_DT_DESC
  PLAYS_STDDEV_SAMPLE_ID_ASC
  PLAYS_STDDEV_SAMPLE_ID_DESC
  PLAYS_STDDEV_SAMPLE_TRACK_ID_ASC
  PLAYS_STDDEV_SAMPLE_TRACK_ID_DESC
  PLAYS_STDDEV_SAMPLE_DT_ASC
  PLAYS_STDDEV_SAMPLE_DT_DESC
  PLAYS_STDDEV_POPULATION_ID_ASC
  PLAYS_STDDEV_POPULATION_ID_DESC
  PLAYS_STDDEV_POPULATION_TRACK_ID_ASC
  PLAYS_STDDEV_POPULATION_TRACK_ID_DESC
  PLAYS_STDDEV_POPULATION_DT_ASC
  PLAYS_STDDEV_POPULATION_DT_DESC
  PLAYS_VARIANCE_SAMPLE_ID_ASC
  PLAYS_VARIANCE_SAMPLE_ID_DESC
  PLAYS_VARIANCE_SAMPLE_TRACK_ID_ASC
  PLAYS_VARIANCE_SAMPLE_TRACK_ID_DESC
  PLAYS_VARIANCE_SAMPLE_DT_ASC
  PLAYS_VARIANCE_SAMPLE_DT_DESC
  PLAYS_VARIANCE_POPULATION_ID_ASC
  PLAYS_VARIANCE_POPULATION_ID_DESC
  PLAYS_VARIANCE_POPULATION_TRACK_ID_ASC
  PLAYS_VARIANCE_POPULATION_TRACK_ID_DESC
  PLAYS_VARIANCE_POPULATION_DT_ASC
  PLAYS_VARIANCE_POPULATION_DT_DESC
}

"""
A condition to be used against `Track` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TrackCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `albumArtist` field."""
  albumArtist: String

  """Checks for equality with the object’s `artist` field."""
  artist: String

  """Checks for equality with the object’s `album` field."""
  album: String

  """Checks for equality with the object’s `discI` field."""
  discI: Int

  """Checks for equality with the object’s `discN` field."""
  discN: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `trackI` field."""
  trackI: Int

  """Checks for equality with the object’s `trackN` field."""
  trackN: Int

  """Checks for equality with the object’s `duration` field."""
  duration: Int

  """Checks for equality with the object’s `composer` field."""
  composer: String

  """Checks for equality with the object’s `grouping` field."""
  grouping: String

  """Checks for equality with the object’s `rating` field."""
  rating: Int

  """Checks for equality with the object’s `year` field."""
  year: Int

  """Checks for equality with the object’s `genre` field."""
  genre: String

  """Checks for equality with the object’s `compilation` field."""
  compilation: Boolean

  """Checks for equality with the object’s `comments` field."""
  comments: String

  """Checks for equality with the object’s `bitrate` field."""
  bitrate: Int

  """Checks for equality with the object’s `startAt` field."""
  startAt: Int

  """Checks for equality with the object’s `stopAt` field."""
  stopAt: Int

  """Checks for equality with the object’s `fileSize` field."""
  fileSize: Int

  """Checks for equality with the object’s `ix` field."""
  ix: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: BigInt

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: BigInt

  """Checks for equality with the object’s `genreCat` field."""
  genreCat: String

  """Checks for equality with the object’s `genreColor` field."""
  genreColor: String

  """Checks for equality with the object’s `lastPlayed` field."""
  lastPlayed: BigInt

  """Checks for equality with the object’s `nPlays` field."""
  nPlays: Int
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `MbArtistRelease`."""
  createMbArtistRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMbArtistReleaseInput!
  ): CreateMbArtistReleasePayload

  """Creates a single `MbArtist`."""
  createMbArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMbArtistInput!
  ): CreateMbArtistPayload

  """Creates a single `MbRelease`."""
  createMbRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMbReleaseInput!
  ): CreateMbReleasePayload

  """Creates a single `PlaylistFolder`."""
  createPlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaylistFolderInput!
  ): CreatePlaylistFolderPayload

  """Creates a single `PlaylistTrack`."""
  createPlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaylistTrackInput!
  ): CreatePlaylistTrackPayload

  """Creates a single `PlaylistTracksHistory`."""
  createPlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaylistTracksHistoryInput!
  ): CreatePlaylistTracksHistoryPayload

  """Creates a single `Playlist`."""
  createPlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaylistInput!
  ): CreatePlaylistPayload

  """Creates a single `Play`."""
  createPlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlayInput!
  ): CreatePlayPayload

  """Creates a single `Track`."""
  createTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTrackInput!
  ): CreateTrackPayload

  """Updates a single `MbArtistRelease` using a unique key and a patch."""
  updateMbArtistRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMbArtistReleaseInput!
  ): UpdateMbArtistReleasePayload

  """Updates a single `MbArtist` using a unique key and a patch."""
  updateMbArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMbArtistInput!
  ): UpdateMbArtistPayload

  """Updates a single `MbRelease` using a unique key and a patch."""
  updateMbRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMbReleaseInput!
  ): UpdateMbReleasePayload

  """Updates a single `PlaylistFolder` using a unique key and a patch."""
  updatePlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistFolderInput!
  ): UpdatePlaylistFolderPayload

  """Updates a single `PlaylistFolder` using a unique key and a patch."""
  updatePlaylistFolderByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistFolderByNameInput!
  ): UpdatePlaylistFolderPayload

  """Updates a single `PlaylistTrack` using a unique key and a patch."""
  updatePlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistTrackInput!
  ): UpdatePlaylistTrackPayload

  """
  Updates a single `PlaylistTracksHistory` using a unique key and a patch.
  """
  updatePlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistTracksHistoryInput!
  ): UpdatePlaylistTracksHistoryPayload

  """Updates a single `Playlist` using a unique key and a patch."""
  updatePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistInput!
  ): UpdatePlaylistPayload

  """Updates a single `Playlist` using a unique key and a patch."""
  updatePlaylistByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaylistByNameInput!
  ): UpdatePlaylistPayload

  """Updates a single `Play` using a unique key and a patch."""
  updatePlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayInput!
  ): UpdatePlayPayload

  """Updates a single `Track` using a unique key and a patch."""
  updateTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTrackInput!
  ): UpdateTrackPayload

  """Deletes a single `MbArtistRelease` using a unique key."""
  deleteMbArtistRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMbArtistReleaseInput!
  ): DeleteMbArtistReleasePayload

  """Deletes a single `MbArtist` using a unique key."""
  deleteMbArtist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMbArtistInput!
  ): DeleteMbArtistPayload

  """Deletes a single `MbRelease` using a unique key."""
  deleteMbRelease(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMbReleaseInput!
  ): DeleteMbReleasePayload

  """Deletes a single `PlaylistFolder` using a unique key."""
  deletePlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistFolderInput!
  ): DeletePlaylistFolderPayload

  """Deletes a single `PlaylistFolder` using a unique key."""
  deletePlaylistFolderByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistFolderByNameInput!
  ): DeletePlaylistFolderPayload

  """Deletes a single `PlaylistTrack` using a unique key."""
  deletePlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistTrackInput!
  ): DeletePlaylistTrackPayload

  """Deletes a single `PlaylistTracksHistory` using a unique key."""
  deletePlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistTracksHistoryInput!
  ): DeletePlaylistTracksHistoryPayload

  """Deletes a single `Playlist` using a unique key."""
  deletePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistInput!
  ): DeletePlaylistPayload

  """Deletes a single `Playlist` using a unique key."""
  deletePlaylistByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistByNameInput!
  ): DeletePlaylistPayload

  """Deletes a single `Play` using a unique key."""
  deletePlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayInput!
  ): DeletePlayPayload

  """Deletes a single `Track` using a unique key."""
  deleteTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTrackInput!
  ): DeleteTrackPayload
  clearPlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ClearPlaylistTracksHistoryInput!
  ): ClearPlaylistTracksHistoryPayload
  createPlaylistTracks(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaylistTracksInput!
  ): CreatePlaylistTracksPayload
  createTracks(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTracksInput!
  ): CreateTracksPayload
  deletePlaylistTracks(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaylistTracksInput!
  ): DeletePlaylistTracksPayload
  emptyPlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: EmptyPlaylistInput!
  ): EmptyPlaylistPayload
  pushPlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PushPlaylistTracksHistoryInput!
  ): PushPlaylistTracksHistoryPayload
  reixPlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ReixPlaylistInput!
  ): ReixPlaylistPayload
  restoreFromPlaylistTracksHistory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RestoreFromPlaylistTracksHistoryInput!
  ): RestoreFromPlaylistTracksHistoryPayload
  shufflePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ShufflePlaylistInput!
  ): ShufflePlaylistPayload

  """Creates one or many `PlaylistFolder`."""
  mnCreatePlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnCreatePlaylistFolderInput!
  ): mnCreatePlaylistFolderPayload

  """Creates one or many `PlaylistTrack`."""
  mnCreatePlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnCreatePlaylistTrackInput!
  ): mnCreatePlaylistTrackPayload

  """Creates one or many `Playlist`."""
  mnCreatePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnCreatePlaylistInput!
  ): mnCreatePlaylistPayload

  """Creates one or many `Play`."""
  mnCreatePlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnCreatePlayInput!
  ): mnCreatePlayPayload

  """Creates one or many `Track`."""
  mnCreateTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnCreateTrackInput!
  ): mnCreateTrackPayload

  """Updates one or many `PlaylistFolder` using a unique key and a patch."""
  mnUpdatePlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnUpdatePlaylistFolderInput!
  ): mnUpdatePlaylistFolderPayload

  """Updates one or many `PlaylistTrack` using a unique key and a patch."""
  mnUpdatePlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnUpdatePlaylistTrackInput!
  ): mnUpdatePlaylistTrackPayload

  """Updates one or many `Playlist` using a unique key and a patch."""
  mnUpdatePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnUpdatePlaylistInput!
  ): mnUpdatePlaylistPayload

  """Updates one or many `Play` using a unique key and a patch."""
  mnUpdatePlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnUpdatePlayInput!
  ): mnUpdatePlayPayload

  """Updates one or many `Track` using a unique key and a patch."""
  mnUpdateTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnUpdateTrackInput!
  ): mnUpdateTrackPayload

  """Deletes one or many `PlaylistFolder` a unique key via a patch."""
  mnDeletePlaylistFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnDeletePlaylistFolderInput!
  ): mnDeletePlaylistFolderPayload

  """Deletes one or many `PlaylistTrack` a unique key via a patch."""
  mnDeletePlaylistTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnDeletePlaylistTrackInput!
  ): mnDeletePlaylistTrackPayload

  """Deletes one or many `Playlist` a unique key via a patch."""
  mnDeletePlaylist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnDeletePlaylistInput!
  ): mnDeletePlaylistPayload

  """Deletes one or many `Play` a unique key via a patch."""
  mnDeletePlay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnDeletePlayInput!
  ): mnDeletePlayPayload

  """Deletes one or many `Track` a unique key via a patch."""
  mnDeleteTrack(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: mnDeleteTrackInput!
  ): mnDeleteTrackPayload
}

"""The output of our create `MbArtistRelease` mutation."""
type CreateMbArtistReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtistRelease` that was created by this mutation."""
  mbArtistRelease: MbArtistRelease

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `MbArtist` that is related to this `MbArtistRelease`."""
  mbArtist: MbArtist

  """Reads a single `MbRelease` that is related to this `MbArtistRelease`."""
  mbRelease: MbRelease

  """An edge for our `MbArtistRelease`. May be used by Relay 1."""
  mbArtistReleaseEdge(
    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistReleasesEdge
}

"""All input for the create `MbArtistRelease` mutation."""
input CreateMbArtistReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MbArtistRelease` to be created by this mutation."""
  mbArtistRelease: MbArtistReleaseInput!
}

"""An input for mutations affecting `MbArtistRelease`"""
input MbArtistReleaseInput {
  mbArtistId: UUID!
  mbReleaseId: UUID!
}

"""The output of our create `MbArtist` mutation."""
type CreateMbArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtist` that was created by this mutation."""
  mbArtist: MbArtist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbArtist`. May be used by Relay 1."""
  mbArtistEdge(
    """The method to use when ordering `MbArtist`."""
    orderBy: [MbArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistsEdge
}

"""All input for the create `MbArtist` mutation."""
input CreateMbArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MbArtist` to be created by this mutation."""
  mbArtist: MbArtistInput!
}

"""An input for mutations affecting `MbArtist`"""
input MbArtistInput {
  id: UUID!
  name: String!
  lastChecked: BigInt
}

"""The output of our create `MbRelease` mutation."""
type CreateMbReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbRelease` that was created by this mutation."""
  mbRelease: MbRelease

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbRelease`. May be used by Relay 1."""
  mbReleaseEdge(
    """The method to use when ordering `MbRelease`."""
    orderBy: [MbReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbReleasesEdge
}

"""All input for the create `MbRelease` mutation."""
input CreateMbReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MbRelease` to be created by this mutation."""
  mbRelease: MbReleaseInput!
}

"""An input for mutations affecting `MbRelease`"""
input MbReleaseInput {
  id: UUID!
  title: String!
  types: [String]!
  ackstate: MbAckstates
  releaseDate: BigInt
  createdAt: BigInt!
}

"""The output of our create `PlaylistFolder` mutation."""
type CreatePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was created by this mutation."""
  playlistFolder: PlaylistFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the create `PlaylistFolder` mutation."""
input CreatePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PlaylistFolder` to be created by this mutation."""
  playlistFolder: PlaylistFolderInput!
}

"""An input for mutations affecting `PlaylistFolder`"""
input PlaylistFolderInput {
  id: Int
  name: String!
  ix: Int
}

"""The output of our create `PlaylistTrack` mutation."""
type CreatePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was created by this mutation."""
  playlistTrack: PlaylistTrack

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the create `PlaylistTrack` mutation."""
input CreatePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PlaylistTrack` to be created by this mutation."""
  playlistTrack: PlaylistTrackInput!
}

"""An input for mutations affecting `PlaylistTrack`"""
input PlaylistTrackInput {
  playlistId: Int!
  trackId: String!
  ix: Int!
}

"""The output of our create `PlaylistTracksHistory` mutation."""
type CreatePlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTracksHistory` that was created by this mutation."""
  playlistTracksHistory: PlaylistTracksHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Playlist` that is related to this `PlaylistTracksHistory`.
  """
  playlist: Playlist

  """
  Reads a single `Track` that is related to this `PlaylistTracksHistory`.
  """
  track: Track

  """An edge for our `PlaylistTracksHistory`. May be used by Relay 1."""
  playlistTracksHistoryEdge(
    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksHistoriesEdge
}

"""All input for the create `PlaylistTracksHistory` mutation."""
input CreatePlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PlaylistTracksHistory` to be created by this mutation."""
  playlistTracksHistory: PlaylistTracksHistoryInput!
}

"""An input for mutations affecting `PlaylistTracksHistory`"""
input PlaylistTracksHistoryInput {
  historyId: Int!
  playlistId: Int!
  trackId: String!
  ix: Int!
}

"""The output of our create `Playlist` mutation."""
type CreatePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was created by this mutation."""
  playlist: Playlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the create `Playlist` mutation."""
input CreatePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Playlist` to be created by this mutation."""
  playlist: PlaylistInput!
}

"""An input for mutations affecting `Playlist`"""
input PlaylistInput {
  id: Int
  playlistFolderId: Int
  name: String!
  sortCol: String
  sortAsc: Boolean
  ix: Int
}

"""The output of our create `Play` mutation."""
type CreatePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was created by this mutation."""
  play: Play

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the create `Play` mutation."""
input CreatePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Play` to be created by this mutation."""
  play: PlayInput!
}

"""An input for mutations affecting `Play`"""
input PlayInput {
  id: Int
  trackId: String!
  dt: BigInt!
}

"""The output of our create `Track` mutation."""
type CreateTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was created by this mutation."""
  track: Track

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the create `Track` mutation."""
input CreateTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Track` to be created by this mutation."""
  track: TrackInput!
}

"""An input for mutations affecting `Track`"""
input TrackInput {
  id: String!
  albumArtist: String
  artist: String
  album: String
  discI: Int
  discN: Int
  title: String
  trackI: Int
  trackN: Int
  duration: Int!
  composer: String
  grouping: String
  rating: Int
  year: Int
  genre: String
  compilation: Boolean
  comments: String
  bitrate: Int!
  startAt: Int
  stopAt: Int
  fileSize: Int!
  ix: Int
  createdAt: BigInt!
  updatedAt: BigInt
}

"""The output of our update `MbArtistRelease` mutation."""
type UpdateMbArtistReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtistRelease` that was updated by this mutation."""
  mbArtistRelease: MbArtistRelease

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `MbArtist` that is related to this `MbArtistRelease`."""
  mbArtist: MbArtist

  """Reads a single `MbRelease` that is related to this `MbArtistRelease`."""
  mbRelease: MbRelease

  """An edge for our `MbArtistRelease`. May be used by Relay 1."""
  mbArtistReleaseEdge(
    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistReleasesEdge
}

"""All input for the `updateMbArtistRelease` mutation."""
input UpdateMbArtistReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MbArtistRelease` being updated.
  """
  patch: MbArtistReleasePatch!
  mbArtistId: UUID!
  mbReleaseId: UUID!
}

"""
Represents an update to a `MbArtistRelease`. Fields that are set will be updated.
"""
input MbArtistReleasePatch {
  mbArtistId: UUID
  mbReleaseId: UUID
}

"""The output of our update `MbArtist` mutation."""
type UpdateMbArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtist` that was updated by this mutation."""
  mbArtist: MbArtist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbArtist`. May be used by Relay 1."""
  mbArtistEdge(
    """The method to use when ordering `MbArtist`."""
    orderBy: [MbArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistsEdge
}

"""All input for the `updateMbArtist` mutation."""
input UpdateMbArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MbArtist` being updated.
  """
  patch: MbArtistPatch!
  id: UUID!
}

"""
Represents an update to a `MbArtist`. Fields that are set will be updated.
"""
input MbArtistPatch {
  id: UUID
  name: String
  lastChecked: BigInt
}

"""The output of our update `MbRelease` mutation."""
type UpdateMbReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbRelease` that was updated by this mutation."""
  mbRelease: MbRelease

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbRelease`. May be used by Relay 1."""
  mbReleaseEdge(
    """The method to use when ordering `MbRelease`."""
    orderBy: [MbReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbReleasesEdge
}

"""All input for the `updateMbRelease` mutation."""
input UpdateMbReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MbRelease` being updated.
  """
  patch: MbReleasePatch!
  id: UUID!
}

"""
Represents an update to a `MbRelease`. Fields that are set will be updated.
"""
input MbReleasePatch {
  id: UUID
  title: String
  types: [String]
  ackstate: MbAckstates
  releaseDate: BigInt
  createdAt: BigInt
}

"""The output of our update `PlaylistFolder` mutation."""
type UpdatePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was updated by this mutation."""
  playlistFolder: PlaylistFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the `updatePlaylistFolder` mutation."""
input UpdatePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlaylistFolder` being updated.
  """
  patch: PlaylistFolderPatch!
  id: Int!
}

"""
Represents an update to a `PlaylistFolder`. Fields that are set will be updated.
"""
input PlaylistFolderPatch {
  id: Int
  name: String
  ix: Int
}

"""All input for the `updatePlaylistFolderByName` mutation."""
input UpdatePlaylistFolderByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlaylistFolder` being updated.
  """
  patch: PlaylistFolderPatch!
  name: String!
}

"""The output of our update `PlaylistTrack` mutation."""
type UpdatePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was updated by this mutation."""
  playlistTrack: PlaylistTrack

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the `updatePlaylistTrack` mutation."""
input UpdatePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlaylistTrack` being updated.
  """
  patch: PlaylistTrackPatch!
  playlistId: Int!
  trackId: String!
}

"""
Represents an update to a `PlaylistTrack`. Fields that are set will be updated.
"""
input PlaylistTrackPatch {
  playlistId: Int
  trackId: String
  ix: Int
}

"""The output of our update `PlaylistTracksHistory` mutation."""
type UpdatePlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTracksHistory` that was updated by this mutation."""
  playlistTracksHistory: PlaylistTracksHistory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Playlist` that is related to this `PlaylistTracksHistory`.
  """
  playlist: Playlist

  """
  Reads a single `Track` that is related to this `PlaylistTracksHistory`.
  """
  track: Track

  """An edge for our `PlaylistTracksHistory`. May be used by Relay 1."""
  playlistTracksHistoryEdge(
    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksHistoriesEdge
}

"""All input for the `updatePlaylistTracksHistory` mutation."""
input UpdatePlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlaylistTracksHistory` being updated.
  """
  patch: PlaylistTracksHistoryPatch!
  historyId: Int!
  playlistId: Int!
  trackId: String!
}

"""
Represents an update to a `PlaylistTracksHistory`. Fields that are set will be updated.
"""
input PlaylistTracksHistoryPatch {
  historyId: Int
  playlistId: Int
  trackId: String
  ix: Int
}

"""The output of our update `Playlist` mutation."""
type UpdatePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was updated by this mutation."""
  playlist: Playlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the `updatePlaylist` mutation."""
input UpdatePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Playlist` being updated.
  """
  patch: PlaylistPatch!
  id: Int!
}

"""
Represents an update to a `Playlist`. Fields that are set will be updated.
"""
input PlaylistPatch {
  id: Int
  playlistFolderId: Int
  name: String
  sortCol: String
  sortAsc: Boolean
  ix: Int
}

"""All input for the `updatePlaylistByName` mutation."""
input UpdatePlaylistByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Playlist` being updated.
  """
  patch: PlaylistPatch!
  name: String!
}

"""The output of our update `Play` mutation."""
type UpdatePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was updated by this mutation."""
  play: Play

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the `updatePlay` mutation."""
input UpdatePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Play` being updated.
  """
  patch: PlayPatch!
  id: Int!
}

"""Represents an update to a `Play`. Fields that are set will be updated."""
input PlayPatch {
  id: Int
  trackId: String
  dt: BigInt
}

"""The output of our update `Track` mutation."""
type UpdateTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was updated by this mutation."""
  track: Track

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the `updateTrack` mutation."""
input UpdateTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Track` being updated.
  """
  patch: TrackPatch!
  id: String!
}

"""
Represents an update to a `Track`. Fields that are set will be updated.
"""
input TrackPatch {
  id: String
  albumArtist: String
  artist: String
  album: String
  discI: Int
  discN: Int
  title: String
  trackI: Int
  trackN: Int
  duration: Int
  composer: String
  grouping: String
  rating: Int
  year: Int
  genre: String
  compilation: Boolean
  comments: String
  bitrate: Int
  startAt: Int
  stopAt: Int
  fileSize: Int
  ix: Int
  createdAt: BigInt
  updatedAt: BigInt
}

"""The output of our delete `MbArtistRelease` mutation."""
type DeleteMbArtistReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtistRelease` that was deleted by this mutation."""
  mbArtistRelease: MbArtistRelease
  deletedMbArtistReleaseNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `MbArtist` that is related to this `MbArtistRelease`."""
  mbArtist: MbArtist

  """Reads a single `MbRelease` that is related to this `MbArtistRelease`."""
  mbRelease: MbRelease

  """An edge for our `MbArtistRelease`. May be used by Relay 1."""
  mbArtistReleaseEdge(
    """The method to use when ordering `MbArtistRelease`."""
    orderBy: [MbArtistReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistReleasesEdge
}

"""All input for the `deleteMbArtistRelease` mutation."""
input DeleteMbArtistReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  mbArtistId: UUID!
  mbReleaseId: UUID!
}

"""The output of our delete `MbArtist` mutation."""
type DeleteMbArtistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbArtist` that was deleted by this mutation."""
  mbArtist: MbArtist
  deletedMbArtistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbArtist`. May be used by Relay 1."""
  mbArtistEdge(
    """The method to use when ordering `MbArtist`."""
    orderBy: [MbArtistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbArtistsEdge
}

"""All input for the `deleteMbArtist` mutation."""
input DeleteMbArtistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `MbRelease` mutation."""
type DeleteMbReleasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MbRelease` that was deleted by this mutation."""
  mbRelease: MbRelease
  deletedMbReleaseNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MbRelease`. May be used by Relay 1."""
  mbReleaseEdge(
    """The method to use when ordering `MbRelease`."""
    orderBy: [MbReleasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MbReleasesEdge
}

"""All input for the `deleteMbRelease` mutation."""
input DeleteMbReleaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `PlaylistFolder` mutation."""
type DeletePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was deleted by this mutation."""
  playlistFolder: PlaylistFolder
  deletedPlaylistFolderNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the `deletePlaylistFolder` mutation."""
input DeletePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deletePlaylistFolderByName` mutation."""
input DeletePlaylistFolderByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete `PlaylistTrack` mutation."""
type DeletePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was deleted by this mutation."""
  playlistTrack: PlaylistTrack
  deletedPlaylistTrackNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the `deletePlaylistTrack` mutation."""
input DeletePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  playlistId: Int!
  trackId: String!
}

"""The output of our delete `PlaylistTracksHistory` mutation."""
type DeletePlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTracksHistory` that was deleted by this mutation."""
  playlistTracksHistory: PlaylistTracksHistory
  deletedPlaylistTracksHistoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Playlist` that is related to this `PlaylistTracksHistory`.
  """
  playlist: Playlist

  """
  Reads a single `Track` that is related to this `PlaylistTracksHistory`.
  """
  track: Track

  """An edge for our `PlaylistTracksHistory`. May be used by Relay 1."""
  playlistTracksHistoryEdge(
    """The method to use when ordering `PlaylistTracksHistory`."""
    orderBy: [PlaylistTracksHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksHistoriesEdge
}

"""All input for the `deletePlaylistTracksHistory` mutation."""
input DeletePlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  historyId: Int!
  playlistId: Int!
  trackId: String!
}

"""The output of our delete `Playlist` mutation."""
type DeletePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was deleted by this mutation."""
  playlist: Playlist
  deletedPlaylistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the `deletePlaylist` mutation."""
input DeletePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deletePlaylistByName` mutation."""
input DeletePlaylistByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete `Play` mutation."""
type DeletePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was deleted by this mutation."""
  play: Play
  deletedPlayNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the `deletePlay` mutation."""
input DeletePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Track` mutation."""
type DeleteTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was deleted by this mutation."""
  track: Track
  deletedTrackNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the `deleteTrack` mutation."""
input DeleteTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our `clearPlaylistTracksHistory` mutation."""
type ClearPlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `clearPlaylistTracksHistory` mutation."""
input ClearPlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `createPlaylistTracks` mutation."""
type CreatePlaylistTracksPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `createPlaylistTracks` mutation."""
input CreatePlaylistTracksInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistTracks: [PlaylistTrackInput]
}

"""The output of our `createTracks` mutation."""
type CreateTracksPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `createTracks` mutation."""
input CreateTracksInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _tracks: [TrackInput]
}

"""The output of our `deletePlaylistTracks` mutation."""
type DeletePlaylistTracksPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePlaylistTracks` mutation."""
input DeletePlaylistTracksInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistId: Int
  _trackIds: [String]
}

"""The output of our `emptyPlaylist` mutation."""
type EmptyPlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `emptyPlaylist` mutation."""
input EmptyPlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistId: Int
}

"""The output of our `pushPlaylistTracksHistory` mutation."""
type PushPlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integers: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `pushPlaylistTracksHistory` mutation."""
input PushPlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistId: Int
  _currentHistoryId: Int
}

"""The output of our `reixPlaylist` mutation."""
type ReixPlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `reixPlaylist` mutation."""
input ReixPlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistId: Int
}

"""The output of our `restoreFromPlaylistTracksHistory` mutation."""
type RestoreFromPlaylistTracksHistoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integers: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `restoreFromPlaylistTracksHistory` mutation."""
input RestoreFromPlaylistTracksHistoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _historyId: Int
}

"""The output of our `shufflePlaylist` mutation."""
type ShufflePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `shufflePlaylist` mutation."""
input ShufflePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  _playlistId: Int
}

"""The output of our many create `PlaylistFolder` mutation."""
type mnCreatePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was created by this mutation."""
  playlistFolder: PlaylistFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the create mn`PlaylistFolder` mutation."""
input mnCreatePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `PlaylistFolder` to be created by this mutation."""
  mnPlaylistFolder: [PlaylistFolderInput!]
}

"""The output of our many create `PlaylistTrack` mutation."""
type mnCreatePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was created by this mutation."""
  playlistTrack: PlaylistTrack

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the create mn`PlaylistTrack` mutation."""
input mnCreatePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `PlaylistTrack` to be created by this mutation."""
  mnPlaylistTrack: [PlaylistTrackInput!]
}

"""The output of our many create `Playlist` mutation."""
type mnCreatePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was created by this mutation."""
  playlist: Playlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the create mn`Playlist` mutation."""
input mnCreatePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Playlist` to be created by this mutation."""
  mnPlaylist: [PlaylistInput!]
}

"""The output of our many create `Play` mutation."""
type mnCreatePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was created by this mutation."""
  play: Play

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the create mn`Play` mutation."""
input mnCreatePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Play` to be created by this mutation."""
  mnPlay: [PlayInput!]
}

"""The output of our many create `Track` mutation."""
type mnCreateTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was created by this mutation."""
  track: Track

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the create mn`Track` mutation."""
input mnCreateTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Track` to be created by this mutation."""
  mnTrack: [TrackInput!]
}

"""The output of our update mn `PlaylistFolder` mutation."""
type mnUpdatePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,                 unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was updated by this mutation."""
  playlistFolder: PlaylistFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the update `mnUpdatePlaylistFolder` mutation."""
input mnUpdatePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `PlaylistFolder` to be updated."""
  mnPatch: [PlaylistFolderPatch!]
}

"""The output of our update mn `PlaylistTrack` mutation."""
type mnUpdatePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,                 unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was updated by this mutation."""
  playlistTrack: PlaylistTrack

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the update `mnUpdatePlaylistTrack` mutation."""
input mnUpdatePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `PlaylistTrack` to be updated."""
  mnPatch: [PlaylistTrackPatch!]
}

"""The output of our update mn `Playlist` mutation."""
type mnUpdatePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,                 unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was updated by this mutation."""
  playlist: Playlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the update `mnUpdatePlaylist` mutation."""
input mnUpdatePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Playlist` to be updated."""
  mnPatch: [PlaylistPatch!]
}

"""The output of our update mn `Play` mutation."""
type mnUpdatePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,                 unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was updated by this mutation."""
  play: Play

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the update `mnUpdatePlay` mutation."""
input mnUpdatePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Play` to be updated."""
  mnPatch: [PlayPatch!]
}

"""The output of our update mn `Track` mutation."""
type mnUpdateTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,                 unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was updated by this mutation."""
  track: Track

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the update `mnUpdateTrack` mutation."""
input mnUpdateTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Track` to be updated."""
  mnPatch: [TrackPatch!]
}

"""The output of our delete mn `PlaylistFolder` mutation."""
type mnDeletePlaylistFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistFolder` that was deleted by this mutation."""
  playlistFolder: PlaylistFolder
  deletedPlaylistFolderNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PlaylistFolder`. May be used by Relay 1."""
  playlistFolderEdge(
    """The method to use when ordering `PlaylistFolder`."""
    orderBy: [PlaylistFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistFoldersEdge
}

"""All input for the delete `mnDeletePlaylistFolder` mutation."""
input mnDeletePlaylistFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The one or many `PlaylistFolder` to be deleted. You must provide the PK values!
  """
  mnPatch: [PlaylistFolderPatch!]
}

"""The output of our delete mn `PlaylistTrack` mutation."""
type mnDeletePlaylistTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlaylistTrack` that was deleted by this mutation."""
  playlistTrack: PlaylistTrack
  deletedPlaylistTrackNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Playlist` that is related to this `PlaylistTrack`."""
  playlist: Playlist

  """Reads a single `Track` that is related to this `PlaylistTrack`."""
  track: Track

  """An edge for our `PlaylistTrack`. May be used by Relay 1."""
  playlistTrackEdge(
    """The method to use when ordering `PlaylistTrack`."""
    orderBy: [PlaylistTracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistTracksEdge
}

"""All input for the delete `mnDeletePlaylistTrack` mutation."""
input mnDeletePlaylistTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The one or many `PlaylistTrack` to be deleted. You must provide the PK values!
  """
  mnPatch: [PlaylistTrackPatch!]
}

"""The output of our delete mn `Playlist` mutation."""
type mnDeletePlaylistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Playlist` that was deleted by this mutation."""
  playlist: Playlist
  deletedPlaylistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlaylistFolder` that is related to this `Playlist`."""
  playlistFolder: PlaylistFolder

  """An edge for our `Playlist`. May be used by Relay 1."""
  playlistEdge(
    """The method to use when ordering `Playlist`."""
    orderBy: [PlaylistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaylistsEdge
}

"""All input for the delete `mnDeletePlaylist` mutation."""
input mnDeletePlaylistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The one or many `Playlist` to be deleted. You must provide the PK values!
  """
  mnPatch: [PlaylistPatch!]
}

"""The output of our delete mn `Play` mutation."""
type mnDeletePlayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Play` that was deleted by this mutation."""
  play: Play
  deletedPlayNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Track` that is related to this `Play`."""
  track: Track

  """An edge for our `Play`. May be used by Relay 1."""
  playEdge(
    """The method to use when ordering `Play`."""
    orderBy: [PlaysOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlaysEdge
}

"""All input for the delete `mnDeletePlay` mutation."""
input mnDeletePlayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Play` to be deleted. You must provide the PK values!"""
  mnPatch: [PlayPatch!]
}

"""The output of our delete mn `Track` mutation."""
type mnDeleteTrackPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Track` that was deleted by this mutation."""
  track: Track
  deletedTrackNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Track`. May be used by Relay 1."""
  trackEdge(
    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksEdge
}

"""All input for the delete `mnDeleteTrack` mutation."""
input mnDeleteTrackInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The one or many `Track` to be deleted. You must provide the PK values!"""
  mnPatch: [TrackPatch!]
}
